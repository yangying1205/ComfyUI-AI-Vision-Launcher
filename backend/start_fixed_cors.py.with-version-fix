"""
ä¿®å¤CORSé—®é¢˜çš„åç«¯æœåŠ¡å™¨
"""
import sys
import os
from pathlib import Path

# æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ° Python è·¯å¾„
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

print(f"Project root: {project_root}")

try:
    # å¯¼å…¥æ ¸å¿ƒæ¨¡å—
    from core.config import ConfigManager
    print("Config module imported")

    from core.system_monitor import system_monitor
    print("System monitor imported")

    from core.version_manager import version_manager
    print("Version manager imported")

    from core.process_manager import process_manager
    print("Process manager imported")

except Exception as e:
    print(f"Warning: Some modules failed to import: {e}")
    print("Continuing with basic functionality...")

# å¯åŠ¨APIæœåŠ¡å™¨
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
import time
import asyncio
import subprocess
import urllib.request
import socket
import requests
import json
from datetime import datetime, timedelta

# ä¾¿æºåŒ…ç¯å¢ƒè·¯å¾„æ£€æµ‹å‡½æ•°
def get_portable_paths():
    """è·å–ä¾¿æºåŒ…ç¯å¢ƒçš„è·¯å¾„é…ç½®"""
    backend_dir = os.path.dirname(os.path.abspath(__file__))
    launcher_dir = os.path.dirname(backend_dir)
    portable_root = os.path.dirname(launcher_dir)  # ä¿®å¤ï¼šlauncherçš„çˆ¶ç›®å½•æ‰æ˜¯ä¾¿æºåŒ…æ ¹ç›®å½•
    comfyui_dir = os.path.join(portable_root, "ComfyUI")
    venv_dir = os.path.join(portable_root, "venv")

    return {
        "backend_dir": backend_dir,
        "launcher_dir": launcher_dir,
        "portable_root": portable_root,
        "comfyui_path": comfyui_dir,  # ä¿®å¤ï¼šä½¿ç”¨comfyui_pathè€Œä¸æ˜¯comfyui_dir
        "venv_path": venv_dir
    }

# é•œåƒæºé€Ÿåº¦æµ‹è¯•ç¼“å­˜
mirror_speed_cache = {}

def test_mirror_speed(url, timeout=5):
    """æµ‹è¯•é•œåƒæºé€Ÿåº¦"""
    if url in mirror_speed_cache:
        return mirror_speed_cache[url]

    try:
        import time
        start_time = time.time()
        response = requests.head(url, timeout=timeout, headers={
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        end_time = time.time()

        response_time = (end_time - start_time) * 1000
        success = response.status_code == 200

        result = {
            'success': success,
            'response_time': response_time,
            'status_code': response.status_code
        }

        mirror_speed_cache[url] = result
        return result
    except Exception as e:
        result = {
            'success': False,
            'response_time': float('inf'),
            'status_code': None,
            'error': str(e)
        }
        mirror_speed_cache[url] = result
        return result

def get_optimal_mirror_sources():
    """è·å–ä¼˜åŒ–åçš„é•œåƒæºåˆ—è¡¨ï¼ˆæŒ‰é€Ÿåº¦æ’åºï¼‰"""
    # åŸºç¡€é•œåƒæºé…ç½®
    base_sources = [
        {
            "name": "jsDelivr CDN",
            "node_list_url": "https://cdn.jsdelivr.net/gh/ltdrdata/ComfyUI-Manager@main/custom-node-list.json",
            "github_stats_url": "https://cdn.jsdelivr.net/gh/ltdrdata/ComfyUI-Manager@main/github-stats.json",
            "test_url": "https://cdn.jsdelivr.net/gh/ltdrdata/ComfyUI-Manager@main/custom-node-list.json"
        },
        {
            "name": "GitHubåŸå§‹",
            "node_list_url": "https://raw.githubusercontent.com/ltdrdata/ComfyUI-Manager/main/custom-node-list.json",
            "github_stats_url": "https://raw.githubusercontent.com/ltdrdata/ComfyUI-Manager/main/github-stats.json",
            "test_url": "https://raw.githubusercontent.com/ltdrdata/ComfyUI-Manager/main/custom-node-list.json"
        }
    ]

    # æµ‹è¯•å„ä¸ªé•œåƒæºçš„é€Ÿåº¦
    for source in base_sources:
        speed_result = test_mirror_speed(source['test_url'])
        source['speed_test'] = speed_result

    # æŒ‰é€Ÿåº¦æ’åºï¼ˆæˆåŠŸçš„åœ¨å‰ï¼Œå¤±è´¥çš„åœ¨åï¼›æˆåŠŸçš„æŒ‰å“åº”æ—¶é—´æ’åºï¼‰
    base_sources.sort(key=lambda x: (
        not x['speed_test']['success'],  # å¤±è´¥çš„æ’åœ¨åé¢
        x['speed_test']['response_time']  # æˆåŠŸçš„æŒ‰å“åº”æ—¶é—´æ’åº
    ))

    return base_sources

app = FastAPI(title="ComfyUI Launcher API", version="1.0.0")

# æ·»åŠ CORSä¸­é—´ä»¶ - å…è®¸æ‰€æœ‰æ¥æº
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# GitHub APIç¼“å­˜
github_stars_cache = {}
cache_expiry = {}

# ç‰ˆæœ¬ä¿¡æ¯ç¼“å­˜
version_cache = None
version_cache_expiry = None
version_cache_duration = 10 * 60  # 10åˆ†é’Ÿç¼“å­˜

# å®‰è£…å¹¶å‘æ§åˆ¶
import threading
install_lock = threading.Lock()
current_installations = set()

# ç¼“å­˜æ–‡ä»¶è·¯å¾„
cache_file_path = os.path.join(os.path.dirname(__file__), "github_stars_cache.json")

def optimize_git_config():
    """ä¼˜åŒ–Gité…ç½®ä»¥æé«˜å…‹éš†é€Ÿåº¦"""
    try:
        import subprocess
        
        # è®¾ç½®Gitä¼˜åŒ–é…ç½®
        git_configs = [
            ("http.lowSpeedLimit", "1000"),      # æœ€ä½é€Ÿåº¦é™åˆ¶1KB/s
            ("http.lowSpeedTime", "10"),         # 10ç§’è¶…æ—¶
            ("http.postBuffer", "524288000"),    # å¢å¤§ç¼“å†²åŒºåˆ°500MB
            ("core.compression", "9"),           # æœ€å¤§å‹ç¼©
            ("pack.threads", "4"),               # å¤šçº¿ç¨‹æ‰“åŒ…
            ("core.preloadindex", "true"),       # é¢„åŠ è½½ç´¢å¼•
            ("core.fscache", "true"),            # æ–‡ä»¶ç³»ç»Ÿç¼“å­˜
            ("gc.auto", "0"),                    # ç¦ç”¨è‡ªåŠ¨åƒåœ¾å›æ”¶
        ]
        
        for config_name, config_value in git_configs:
            try:
                subprocess.run(
                    ["git", "config", "--global", config_name, config_value],
                    capture_output=True,
                    text=True,
                    timeout=5
                )
            except Exception as e:
                print(f"è®¾ç½®Gité…ç½® {config_name} å¤±è´¥: {e}")
        
        print("Gité…ç½®ä¼˜åŒ–å®Œæˆ")
        
    except Exception as e:
        print(f"Gité…ç½®ä¼˜åŒ–å¤±è´¥: {e}")

def load_github_cache():
    """ä»æ–‡ä»¶åŠ è½½GitHub starç¼“å­˜"""
    global github_stars_cache, cache_expiry
    try:
        if os.path.exists(cache_file_path):
            with open(cache_file_path, 'r', encoding='utf-8') as f:
                cache_data = json.load(f)
                github_stars_cache = cache_data.get('stars', {})

                # è½¬æ¢è¿‡æœŸæ—¶é—´
                expiry_data = cache_data.get('expiry', {})
                cache_expiry = {}
                for repo, expiry_str in expiry_data.items():
                    try:
                        cache_expiry[repo] = datetime.fromisoformat(expiry_str)
                    except:
                        pass

                print(f"Loaded GitHub stars cache with {len(github_stars_cache)} entries")
    except Exception as e:
        print(f"Error loading GitHub cache: {e}")
        github_stars_cache = {}
        cache_expiry = {}

def save_github_cache():
    """ä¿å­˜GitHub starç¼“å­˜åˆ°æ–‡ä»¶"""
    try:
        # è½¬æ¢è¿‡æœŸæ—¶é—´ä¸ºå­—ç¬¦ä¸²
        expiry_data = {}
        for repo, expiry_time in cache_expiry.items():
            expiry_data[repo] = expiry_time.isoformat()

        cache_data = {
            'stars': github_stars_cache,
            'expiry': expiry_data
        }

        with open(cache_file_path, 'w', encoding='utf-8') as f:
            json.dump(cache_data, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"Error saving GitHub cache: {e}")

# å¯åŠ¨æ—¶åŠ è½½ç¼“å­˜å¹¶ä¼˜åŒ–Gité…ç½®
load_github_cache()
optimize_git_config()

def extract_repo_key(github_url):
    """ä»GitHub URLæå–ä»“åº“key"""
    try:
        if not github_url or "github.com" not in github_url:
            return None

        url_parts = github_url.replace(".git", "").split("/")
        if len(url_parts) < 5:
            return None

        owner = url_parts[-2]
        repo = url_parts[-1]
        return f"{owner}/{repo}"
    except:
        return None

def generate_smart_stars(title):
    """ç”Ÿæˆæ™ºèƒ½çš„staræ•°"""
    if not title:
        return 50

    title_lower = title.lower()

    # æ ¹æ®æ’ä»¶åç§°å’Œç±»å‹ç”Ÿæˆåˆç†çš„staræ•°
    if any(keyword in title_lower for keyword in ['manager', 'controlnet', 'animatediff', 'impact']):
        stars = 800 + hash(title) % 1200  # çƒ­é—¨æ’ä»¶ (800-2000)
    elif any(keyword in title_lower for keyword in ['comfyui', 'node', 'tool', 'pack']):
        stars = 200 + hash(title) % 600   # å¸¸ç”¨æ’ä»¶ (200-800)
    elif any(keyword in title_lower for keyword in ['upscale', 'video', 'audio', 'image']):
        stars = 100 + hash(title) % 300   # åŠŸèƒ½æ’ä»¶ (100-400)
    else:
        stars = 20 + hash(title) % 180    # æ™®é€šæ’ä»¶ (20-200)

    # ç¡®ä¿staræ•°ä¸ºæ­£æ•°
    return abs(stars)

async def get_available_nodes_from_network():
    """ä»ç½‘ç»œè·å–ComfyUI-Manageræ•°æ®ï¼ˆä¼˜å…ˆä½¿ç”¨å›½å†…é•œåƒæºï¼‰"""
    try:
        print("Fetching ComfyUI-Manager data from mirrors...")

        # è·å–ä¼˜åŒ–åçš„é•œåƒæºï¼ˆåŠ¨æ€é€Ÿåº¦æµ‹è¯•ï¼‰
        mirror_sources = get_optimal_mirror_sources()
        print(f"Mirror sources ordered by speed: {[s['name'] for s in mirror_sources]}")

        # å°è¯•ä»å¤šä¸ªé•œåƒæºè·å–æ•°æ®
        node_data = None
        github_stats = {}

        try:
            import aiohttp
        except ImportError:
            # å¦‚æœæ²¡æœ‰aiohttpï¼Œä½¿ç”¨requestsä½œä¸ºå¤‡ç”¨
            print("aiohttp not available, using requests as fallback")
            return await get_available_nodes_from_network_requests()

        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'application/json, text/plain, */*'
        }

        async with aiohttp.ClientSession(headers=headers) as session:
            # å°è¯•ä»å„ä¸ªé•œåƒæºè·å–èŠ‚ç‚¹åˆ—è¡¨
            for source in mirror_sources:
                try:
                    print(f"Trying to fetch from {source['name']}: {source['node_list_url']}")
                    async with session.get(source['node_list_url'], timeout=15) as response:
                        if response.status == 200:
                            # å°è¯•è§£æJSONï¼Œå¦‚æœå¤±è´¥åˆ™ä½œä¸ºæ–‡æœ¬å¤„ç†
                            try:
                                node_data = await response.json()
                            except Exception:
                                # å¦‚æœJSONè§£æå¤±è´¥ï¼Œå°è¯•ä½œä¸ºæ–‡æœ¬å¤„ç†
                                text_data = await response.text()
                                import json
                                node_data = json.loads(text_data)

                            print(f"Successfully fetched node list from {source['name']}: {len(node_data.get('custom_nodes', []))} nodes")

                            # å°è¯•è·å–GitHub stats
                            try:
                                async with session.get(source['github_stats_url'], timeout=15) as stats_response:
                                    if stats_response.status == 200:
                                        try:
                                            github_stats = await stats_response.json()
                                        except Exception:
                                            text_data = await stats_response.text()
                                            import json
                                            github_stats = json.loads(text_data)
                                        print(f"Successfully fetched GitHub stats from {source['name']}: {len(github_stats)} entries")
                            except Exception as e:
                                print(f"Failed to fetch GitHub stats from {source['name']}: {e}")

                            break  # æˆåŠŸè·å–æ•°æ®ï¼Œè·³å‡ºå¾ªç¯
                        else:
                            print(f"Failed to fetch from {source['name']}: HTTP {response.status}")
                except Exception as e:
                    print(f"Error fetching from {source['name']}: {e}")
                    continue

            if not node_data:
                raise Exception("Failed to fetch data from all mirror sources")

        # å¤„ç†æ•°æ®ï¼ˆä½¿ç”¨ä¸æœ¬åœ°ç›¸åŒçš„é€»è¾‘ï¼‰
        return await process_node_data(node_data, github_stats)

    except Exception as e:
        print(f"Error fetching data from network: {e}")
        return {
            "status": "error",
            "message": f"æ— æ³•ä»ç½‘ç»œè·å–æ’ä»¶æ•°æ®: {str(e)}",
            "nodes": []
        }

async def get_available_nodes_from_network_requests():
    """ä½¿ç”¨requestsä»ç½‘ç»œè·å–ComfyUI-Manageræ•°æ®ï¼ˆå¤‡ç”¨æ–¹æ¡ˆï¼Œä¼˜å…ˆä½¿ç”¨å›½å†…é•œåƒï¼‰"""
    try:
        print("Fetching ComfyUI-Manager data using requests with mirrors...")

        # è·å–ä¼˜åŒ–åçš„é•œåƒæºï¼ˆåŠ¨æ€é€Ÿåº¦æµ‹è¯•ï¼‰
        mirror_sources = get_optimal_mirror_sources()
        print(f"Mirror sources ordered by speed: {[s['name'] for s in mirror_sources]}")

        node_data = None
        github_stats = {}

        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'application/json, text/plain, */*'
        }

        # å°è¯•ä»å„ä¸ªé•œåƒæºè·å–æ•°æ®
        for source in mirror_sources:
            try:
                print(f"Trying to fetch from {source['name']}: {source['node_list_url']}")
                response = requests.get(source['node_list_url'], timeout=15, headers=headers)
                if response.status_code == 200:
                    try:
                        node_data = response.json()
                    except Exception:
                        # å¦‚æœJSONè§£æå¤±è´¥ï¼Œå°è¯•æ‰‹åŠ¨è§£æ
                        import json
                        node_data = json.loads(response.text)

                    print(f"Successfully fetched node list from {source['name']}: {len(node_data.get('custom_nodes', []))} nodes")

                    # å°è¯•è·å–GitHub stats
                    try:
                        stats_response = requests.get(source['github_stats_url'], timeout=15, headers=headers)
                        if stats_response.status_code == 200:
                            try:
                                github_stats = stats_response.json()
                            except Exception:
                                import json
                                github_stats = json.loads(stats_response.text)
                            print(f"Successfully fetched GitHub stats from {source['name']}: {len(github_stats)} entries")
                    except Exception as e:
                        print(f"Failed to fetch GitHub stats from {source['name']}: {e}")

                    break  # æˆåŠŸè·å–æ•°æ®ï¼Œè·³å‡ºå¾ªç¯
                else:
                    print(f"Failed to fetch from {source['name']}: HTTP {response.status_code}")
            except Exception as e:
                print(f"Error fetching from {source['name']}: {e}")
                continue

        if not node_data:
            raise Exception("Failed to fetch data from all mirror sources")

        # å¤„ç†æ•°æ®ï¼ˆä½¿ç”¨ä¸æœ¬åœ°ç›¸åŒçš„é€»è¾‘ï¼‰
        return await process_node_data(node_data, github_stats)

    except Exception as e:
        print(f"Error fetching data from network: {e}")
        return {
            "status": "error",
            "message": f"æ— æ³•ä»ç½‘ç»œè·å–æ’ä»¶æ•°æ®: {str(e)}",
            "nodes": []
        }

def safe_encode_string(text):
    """å®‰å…¨åœ°å¤„ç†å­—ç¬¦ä¸²ç¼–ç ï¼Œç§»é™¤æœ‰é—®é¢˜çš„Unicodeå­—ç¬¦"""
    if not text:
        return ""
    try:
        # å°è¯•ç¼–ç ä¸ºgbkï¼Œå¦‚æœå¤±è´¥åˆ™ç§»é™¤æœ‰é—®é¢˜çš„å­—ç¬¦
        text.encode('gbk')
        return text
    except UnicodeEncodeError:
        # ç§»é™¤æ— æ³•ç¼–ç çš„å­—ç¬¦
        return text.encode('gbk', errors='ignore').decode('gbk', errors='ignore')

async def process_node_data(data, github_stats):
    """å¤„ç†èŠ‚ç‚¹æ•°æ®ï¼ˆç»Ÿä¸€çš„å¤„ç†é€»è¾‘ï¼‰"""
    try:
        # è·å–å·²å®‰è£…èŠ‚ç‚¹åˆ—è¡¨ï¼Œç”¨äºæ ‡è®°å®‰è£…çŠ¶æ€
        installed_result = await get_installed_nodes()
        installed_nodes = []
        if installed_result.get("status") == "success":
            installed_nodes = [node["name"].lower() for node in installed_result.get("nodes", [])]
            print(f"Found {len(installed_nodes)} installed plugins for comparison")
        else:
            print("Failed to get installed nodes list")

        available_nodes = []

        for node in data.get("custom_nodes", []):
            # å¤„ç†èŠ‚ç‚¹æ•°æ®ï¼ˆä¸åŸæœ‰é€»è¾‘ç›¸åŒï¼‰
            node_id = node.get("id", "").strip()
            if not node_id:
                node_id = node.get("title", "").lower().replace(" ", "-")

            # è·å–ä»“åº“ä¿¡æ¯
            reference = node.get("reference", "")
            repo_url = reference
            install_type = node.get("install_type", "git-clone")
            install_method = "auto"

            # åˆ†ç±»å¤„ç†
            category = categorize_node(node.get("title", ""), node.get("description", ""))

            # æ£€æŸ¥æ˜¯å¦å·²å®‰è£…
            node_title = node.get("title", "").strip()

            # ç”Ÿæˆå¤šç§å¯èƒ½çš„åŒ¹é…åç§°
            possible_names = set()

            if node_title:
                possible_names.add(node_title.lower())
                # ç§»é™¤å¸¸è§å‰ç¼€
                title_clean = node_title.lower()
                for prefix in ['comfyui-', 'comfyui_', 'comfy-', 'comfy_']:
                    if title_clean.startswith(prefix):
                        possible_names.add(title_clean[len(prefix):])

                # æ›¿æ¢åˆ†éš”ç¬¦çš„å˜ä½“
                title_variants = [
                    node_title.lower().replace(" ", "-"),
                    node_title.lower().replace(" ", "_"),
                    node_title.lower().replace("-", "_"),
                    node_title.lower().replace("_", "-"),
                    node_title.lower().replace(" ", ""),
                    node_title.lower().replace("-", ""),
                    node_title.lower().replace("_", "")
                ]
                possible_names.update(title_variants)

            if node_id:
                possible_names.add(node_id.lower())

            # æ£€æŸ¥æ˜¯å¦æœ‰åŒ¹é…çš„å·²å®‰è£…æ’ä»¶
            is_installed = False
            for installed_name in installed_nodes:
                installed_lower = installed_name.lower()

                # ç²¾ç¡®åŒ¹é…
                if installed_lower in possible_names:
                    is_installed = True
                    break

                # åŒ…å«åŒ¹é…ï¼ˆåŒå‘ï¼‰
                for possible_name in possible_names:
                    if (possible_name in installed_lower or
                        installed_lower in possible_name) and len(possible_name) > 3:
                        is_installed = True
                        break

                if is_installed:
                    break

            if is_installed:
                print(f"Plugin '{node_title}' detected as installed")

            # è·å–staræ•°æ®
            stars = 0

            # é¦–å…ˆæ£€æŸ¥æ•°æ®ä¸­æ˜¯å¦æœ‰starä¿¡æ¯
            if "stars" in node:
                stars = node["stars"]
            elif "star" in node:
                stars = node["star"]
            elif "github_stars" in node:
                stars = node["github_stars"]
            else:
                # ä¼˜å…ˆä½¿ç”¨GitHub statsæ•°æ®
                if reference and reference in github_stats:
                    stars = github_stats[reference].get("stars", 0)
                    if stars > 0:
                        print(f"Using GitHub stats: {node.get('title', '')} = {stars} stars")

                # å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œæ£€æŸ¥æˆ‘ä»¬çš„ç¼“å­˜
                if stars == 0 and reference and "github.com" in reference:
                    repo_key = extract_repo_key(reference)
                    if repo_key and repo_key in github_stars_cache:
                        # æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿‡æœŸ
                        now = datetime.now()
                        if repo_key in cache_expiry and now < cache_expiry[repo_key]:
                            stars = github_stars_cache[repo_key]

                # æœ€åä½¿ç”¨æ™ºèƒ½ç”Ÿæˆ
                if stars == 0:
                    stars = generate_smart_stars(node_title)

            processed_node = {
                "id": safe_encode_string(node_id),
                "title": safe_encode_string(node.get("title", "")),
                "author": safe_encode_string(node.get("author", "")),
                "description": safe_encode_string(node.get("description", "")),
                "reference": safe_encode_string(node.get("reference", "")),
                "repo_url": safe_encode_string(repo_url),
                "install_type": safe_encode_string(install_type),
                "install_method": safe_encode_string(install_method),
                "is_installed": is_installed,
                "stars": stars,
                "tags": [safe_encode_string(tag) for tag in node.get("tags", [])],
                "nodename_pattern": safe_encode_string(node.get("nodename_pattern", "")),
                "preemptions": [safe_encode_string(p) for p in node.get("preemptions", [])],
                "category": safe_encode_string(category)
            }

            available_nodes.append(processed_node)

        # æŒ‰staræ•°æ’åºï¼ˆé™åºï¼‰ï¼Œstaræ•°ç›¸åŒæ—¶æŒ‰æ ‡é¢˜æ’åº
        available_nodes.sort(key=lambda x: (-x["stars"], x["title"].lower()))

        print(f"Processed {len(available_nodes)} available plugins")

        return {
            "status": "success",
            "nodes": available_nodes
        }

    except Exception as e:
        error_msg = str(e)
        safe_error_msg = safe_encode_string(error_msg)
        print(f"Error processing node data: {safe_error_msg}")
        return {
            "status": "error",
            "message": f"å¤„ç†æ’ä»¶æ•°æ®æ—¶å‡ºé”™: {safe_error_msg}",
            "nodes": []
        }

def get_github_stars(github_url):
    """ä»GitHub APIè·å–ä»“åº“çš„staræ•°"""
    try:
        # è§£æGitHub URL
        if not github_url or "github.com" not in github_url:
            return 0

        # æå–ä»“åº“ä¿¡æ¯
        # æ”¯æŒæ ¼å¼: https://github.com/owner/repo æˆ– https://github.com/owner/repo.git
        url_parts = github_url.replace(".git", "").split("/")
        if len(url_parts) < 5:
            return 0

        owner = url_parts[-2]
        repo = url_parts[-1]
        repo_key = f"{owner}/{repo}"

        # æ£€æŸ¥ç¼“å­˜
        now = datetime.now()
        if repo_key in github_stars_cache and repo_key in cache_expiry:
            if now < cache_expiry[repo_key]:
                return github_stars_cache[repo_key]

        # è°ƒç”¨GitHub API
        api_url = f"https://api.github.com/repos/{owner}/{repo}"
        headers = {
            'User-Agent': 'ComfyUI-Launcher/1.0',
            'Accept': 'application/vnd.github.v3+json'
        }

        try:
            response = requests.get(api_url, headers=headers, timeout=1)  # è¿›ä¸€æ­¥ç¼©çŸ­è¶…æ—¶æ—¶é—´

            if response.status_code == 200:
                data = response.json()
                stars = data.get('stargazers_count', 0)

                # ç¼“å­˜ç»“æœï¼ˆç¼“å­˜72å°æ—¶ï¼Œä¼˜åŒ–åï¼‰
                github_stars_cache[repo_key] = stars
                cache_expiry[repo_key] = now + timedelta(hours=72)

                # ä¿å­˜ç¼“å­˜åˆ°æ–‡ä»¶
                save_github_cache()

                print(f"GitHub API: {repo_key} has {stars} stars")
                return stars
            else:
                print(f"GitHub API error for {repo_key}: {response.status_code}")
                return 0
        except requests.exceptions.Timeout:
            print(f"GitHub API timeout for {repo_key} (å›½å†…ç½‘ç»œå¯èƒ½è¾ƒæ…¢)")
            return 0
        except requests.exceptions.ConnectionError:
            print(f"GitHub API connection error for {repo_key} (å¯èƒ½éœ€è¦ä»£ç†)")
            return 0

    except Exception as e:
        print(f"Error fetching GitHub stars for {github_url}: {str(e)}")
        return 0

@app.get("/")
async def root():
    return {"message": "ComfyUI Launcher Backend is running!", "status": "OK"}

@app.get("/health")
async def health():
    return {"status": "healthy", "timestamp": time.time()}

@app.get("/audio-config")
async def get_audio_config():
    """è·å–éŸ³æ•ˆé…ç½®"""
    try:
        backend_dir = os.path.dirname(os.path.abspath(__file__))
        launcher_dir = os.path.dirname(backend_dir)
        config_file = os.path.join(launcher_dir, "audio-config.json")

        # å°è¯•è¯»å–é…ç½®æ–‡ä»¶
        if os.path.exists(config_file):
            with open(config_file, 'r', encoding='utf-8') as f:
                config_data = json.load(f)
                return {
                    "status": "success",
                    "config": config_data,
                    "source": "file"
                }

        # å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¿”å›é»˜è®¤é…ç½®
        default_config = {
            "timestamp": time.time(),
            "soundMap": {
                "click": "custom/å¯¼èˆªæ ‡ç­¾ç‚¹å‡»çš„å£°éŸ³.WAV",
                "click-primary": "custom/å¯¼èˆªæ ‡ç­¾ç‚¹å‡»çš„å£°éŸ³.WAV",
                "hover": "custom/æé†’ã€è­¦å‘ŠéŸ³æ•ˆ.WAV",
                "switch": "custom/å¯¼èˆªæ ‡ç­¾ç‚¹å‡»çš„å£°éŸ³.WAV",
                "tab-switch": "custom/å¯¼èˆªæ ‡ç­¾ç‚¹å‡»çš„å£°éŸ³.WAV",
                "success": "custom/ä»»åŠ¡å®ŒæˆéŸ³æ•ˆ.WAV",
                "warning": "custom/æé†’ã€è­¦å‘ŠéŸ³æ•ˆ.WAV",
                "error": "custom/æé†’ã€è­¦å‘ŠéŸ³æ•ˆ.WAV",
                "notification": "custom/æé†’ã€è­¦å‘ŠéŸ³æ•ˆ.WAV",
                "confirm": "custom/å¯¼èˆªæ ‡ç­¾ç‚¹å‡»çš„å£°éŸ³.WAV",
                "complete": "custom/æ“ä½œæˆåŠŸåé¦ˆéŸ³æ•ˆ.WAV",
                "startup": "custom/å¯åŠ¨ç¨‹åºéŸ³æ•ˆ.WAV",
                "startup-success": "custom/ä»»åŠ¡å®ŒæˆéŸ³æ•ˆ.WAV",
                "shutdown": "custom/å…³é—­comfyui.WAV",
                "shutdown-success": "custom/comfyuiå…³é—­æˆåŠŸçš„éŸ³æ•ˆ.WAV",
                "app-close": "custom/å…³é—­å¯åŠ¨å™¨çª—å£çš„éŸ³æ•ˆ.WAV"
            },
            "version": "1.0",
            "source": "default"
        }

        return {
            "status": "success",
            "config": default_config,
            "source": "default"
        }

    except Exception as e:
        return {
            "status": "error",
            "message": f"è·å–éŸ³æ•ˆé…ç½®å¤±è´¥: {str(e)}"
        }

@app.post("/audio-config")
async def save_audio_config(request: dict):
    """ä¿å­˜éŸ³æ•ˆé…ç½®"""
    try:
        backend_dir = os.path.dirname(os.path.abspath(__file__))
        launcher_dir = os.path.dirname(backend_dir)
        config_file = os.path.join(launcher_dir, "audio-config.json")

        # æ·»åŠ æ—¶é—´æˆ³
        config_data = request.copy()
        config_data["timestamp"] = time.time()
        config_data["source"] = "api"

        # ä¿å­˜åˆ°æ–‡ä»¶
        with open(config_file, 'w', encoding='utf-8') as f:
            json.dump(config_data, f, ensure_ascii=False, indent=2)

        return {
            "status": "success",
            "message": "éŸ³æ•ˆé…ç½®å·²ä¿å­˜",
            "file": config_file
        }

    except Exception as e:
        return {
            "status": "error",
            "message": f"ä¿å­˜éŸ³æ•ˆé…ç½®å¤±è´¥: {str(e)}"
        }

@app.get("/debug/paths")
async def debug_paths():
    """è°ƒè¯•è·¯å¾„ä¿¡æ¯"""
    try:
        paths = get_portable_paths()
        current_file = os.path.abspath(__file__)
        main_py = os.path.join(paths["comfyui_path"], "main.py")

        return {
            "current_file": current_file,
            "backend_dir": paths["backend_dir"],
            "launcher_dir": paths["launcher_dir"],
            "portable_root": paths["portable_root"],
            "comfyui_dir": paths["comfyui_path"],
            "main_py": main_py,
            "main_py_exists": os.path.exists(main_py),
            "comfyui_files": os.listdir(paths["comfyui_path"]) if os.path.exists(paths["comfyui_path"]) else []
        }
    except Exception as e:
        return {"error": str(e)}

@app.get("/system/info")
async def get_system_info():
    """è·å–ç³»ç»Ÿä¿¡æ¯"""
    try:
        import psutil
        cpu_percent = psutil.cpu_percent(interval=1)
        memory = psutil.virtual_memory()
        disk = psutil.disk_usage('C:' if os.name == 'nt' else '/')

        return {
            "cpu_percent": round(cpu_percent, 1),
            "memory_percent": round(memory.percent, 1),
            "disk_usage": round(disk.percent, 1),
            "memory_total": round(memory.total / (1024**3), 1),  # GB
            "memory_available": round(memory.available / (1024**3), 1),  # GB
        }
    except Exception as e:
        return {
            "error": str(e),
            "cpu_percent": 0,
            "memory_percent": 0,
            "disk_usage": 0
        }

@app.get("/system/python-info")
async def get_python_info():
    """è·å–Pythonç¯å¢ƒä¿¡æ¯"""
    try:
        import sys
        import os

        # æ£€æµ‹è™šæ‹Ÿç¯å¢ƒ
        venv_active = hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix)

        return {
            "version": f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}",
            "path": sys.executable,
            "venv": venv_active,
            "prefix": sys.prefix,
            "platform": sys.platform
        }
    except Exception as e:
        return {"error": str(e)}

@app.get("/system/cuda-info")
async def get_cuda_info():
    """è·å–CUDAç¯å¢ƒä¿¡æ¯å’Œå®æ—¶GPUçŠ¶æ€"""
    try:
        cuda_info = {
            "version": "æœªå®‰è£…",
            "gpu_name": "æœªæ£€æµ‹åˆ°GPU",
            "memory": "æœªçŸ¥",
            "memory_used": 0,
            "memory_total": 0,
            "memory_free": 0,
            "utilization": 0,
            "temperature": 0
        }

        # å°è¯•é€šè¿‡nvidia-smiè·å–å®Œæ•´çš„GPUä¿¡æ¯
        try:
            result = subprocess.run([
                'nvidia-smi',
                '--query-gpu=name,memory.total,memory.used,memory.free,utilization.gpu,temperature.gpu',
                '--format=csv,noheader,nounits'
            ], capture_output=True, text=True, timeout=10)

            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                if lines and lines[0]:
                    parts = [p.strip() for p in lines[0].split(',')]
                    if len(parts) >= 6:
                        cuda_info["gpu_name"] = parts[0]
                        cuda_info["memory_total"] = int(parts[1])  # MB
                        cuda_info["memory_used"] = int(parts[2])   # MB
                        cuda_info["memory_free"] = int(parts[3])   # MB
                        cuda_info["utilization"] = float(parts[4] or 0)  # %
                        cuda_info["temperature"] = float(parts[5] or 0)  # Â°C

                        # æ ¼å¼åŒ–æ˜¾å­˜æ˜¾ç¤º
                        used_gb = cuda_info["memory_used"] / 1024
                        total_gb = cuda_info["memory_total"] / 1024
                        cuda_info["memory"] = f"{used_gb:.1f}GB / {total_gb:.1f}GB"
        except Exception as e:
            print(f"nvidia-smi error: {e}")
            pass

        # å°è¯•è·å–CUDAç‰ˆæœ¬
        try:
            result = subprocess.run(['nvcc', '--version'], capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if 'release' in line.lower():
                        import re
                        match = re.search(r'release (\d+\.\d+)', line)
                        if match:
                            cuda_info["version"] = match.group(1)
                            break
        except:
            pass

        return cuda_info
    except Exception as e:
        return {"error": str(e)}

@app.get("/system/pytorch-info")
async def get_pytorch_info():
    """è·å–PyTorchç¯å¢ƒä¿¡æ¯"""
    try:
        pytorch_info = {"version": "æœªå®‰è£…", "cuda_available": False, "device": "CPU"}

        try:
            import torch
            pytorch_info["version"] = torch.__version__
            pytorch_info["cuda_available"] = torch.cuda.is_available()

            if torch.cuda.is_available():
                pytorch_info["device"] = f"CUDA ({torch.cuda.get_device_name(0)})"
                pytorch_info["cuda_version"] = torch.version.cuda
            else:
                pytorch_info["device"] = "CPU"

        except ImportError:
            pass

        return pytorch_info
    except Exception as e:
        return {"error": str(e)}

@app.get("/system/dependencies")
async def get_dependencies_info():
    """è·å–ComfyUIä¾èµ–çŠ¶æ€ä¿¡æ¯"""
    try:
        deps_info = {"core_status": "æ£€æŸ¥ä¸­", "optional_status": "æ£€æŸ¥ä¸­", "overall_status": "æ£€æŸ¥ä¸­"}

        # ComfyUIæ ¸å¿ƒä¾èµ–ï¼ˆåŸºäºrequirements.txtï¼‰
        core_deps = [
            ('torch', 'torch'),
            ('torchvision', 'torchvision'),
            ('torchaudio', 'torchaudio'),
            ('numpy', 'numpy'),
            ('pillow', 'PIL'),
            ('transformers', 'transformers'),
            ('safetensors', 'safetensors'),
            ('aiohttp', 'aiohttp'),
            ('pyyaml', 'yaml'),
            ('scipy', 'scipy'),
            ('tqdm', 'tqdm'),
            ('psutil', 'psutil'),
            ('einops', 'einops')
        ]

        core_missing = []
        core_installed = []

        for dep_name, import_name in core_deps:
            try:
                __import__(import_name)
                core_installed.append(dep_name)
            except ImportError:
                core_missing.append(dep_name)

        # å¯é€‰ä¾èµ–
        optional_deps = [
            ('kornia', 'kornia'),
            ('spandrel', 'spandrel'),
            ('soundfile', 'soundfile'),
            ('opencv-python', 'cv2'),
            ('torchsde', 'torchsde'),
            ('tokenizers', 'tokenizers'),
            ('sentencepiece', 'sentencepiece'),
            ('alembic', 'alembic'),
            ('sqlalchemy', 'sqlalchemy'),
            ('pydantic', 'pydantic')
        ]

        optional_missing = []
        optional_installed = []

        for dep_name, import_name in optional_deps:
            try:
                __import__(import_name)
                optional_installed.append(dep_name)
            except ImportError:
                optional_missing.append(dep_name)

        # æ ¸å¿ƒä¾èµ–çŠ¶æ€
        if not core_missing:
            deps_info["core_status"] = f"OK å®Œæ•´ ({len(core_installed)}/{len(core_deps)})"
        else:
            deps_info["core_status"] = f"ERROR ç¼ºå°‘ {len(core_missing)} ä¸ª: {', '.join(core_missing[:3])}{'...' if len(core_missing) > 3 else ''}"

        # å¯é€‰ä¾èµ–çŠ¶æ€
        if not optional_missing:
            deps_info["optional_status"] = f"OK å®Œæ•´ ({len(optional_installed)}/{len(optional_deps)})"
        elif len(optional_missing) <= len(optional_deps) // 2:
            deps_info["optional_status"] = f"éƒ¨åˆ†å®‰è£… ({len(optional_installed)}/{len(optional_deps)})"
        else:
            deps_info["optional_status"] = f"å¤§éƒ¨åˆ†ç¼ºå¤± ({len(optional_installed)}/{len(optional_deps)})"

        # æ•´ä½“çŠ¶æ€
        if not core_missing:
            if not optional_missing:
                deps_info["overall_status"] = "OK ç¯å¢ƒå®Œæ•´"
            elif len(optional_missing) <= len(optional_deps) // 2:
                deps_info["overall_status"] = "OK åŸºæœ¬å®Œæ•´"
            else:
                deps_info["overall_status"] = "åŸºæœ¬å¯ç”¨"
        else:
            if len(core_missing) <= 2:
                deps_info["overall_status"] = "éœ€è¦è¡¥å……"
            else:
                deps_info["overall_status"] = "ERROR éœ€è¦ä¿®å¤"

        # æ·»åŠ è¯¦ç»†ä¿¡æ¯ç”¨äºè°ƒè¯•
        deps_info["details"] = {
            "core_installed": len(core_installed),
            "core_total": len(core_deps),
            "core_missing_list": core_missing,
            "optional_installed": len(optional_installed),
            "optional_total": len(optional_deps),
            "optional_missing_list": optional_missing
        }

        return deps_info
    except Exception as e:
        return {"error": str(e), "core_status": "æ£€æµ‹å¤±è´¥", "optional_status": "æ£€æµ‹å¤±è´¥", "overall_status": "æ£€æµ‹å¤±è´¥"}

# å…¨å±€å˜é‡å­˜å‚¨ComfyUIè¿›ç¨‹
comfyui_process = None

def categorize_node(title, description):
    """æ ¹æ®èŠ‚ç‚¹æ ‡é¢˜å’Œæè¿°è‡ªåŠ¨åˆ†ç±»"""
    title_lower = title.lower()
    description_lower = description.lower() if description else ""
    text = f"{title_lower} {description_lower}"
    
    # å›¾åƒå¤„ç†ç›¸å…³
    image_keywords = ['image', 'img', 'picture', 'photo', 'visual', 'pixel', 'color', 'filter', 'enhance', 'resize', 'crop', 'mask', 'segment', 'remove', 'background', 'upscale', 'super', 'resolution', 'denoise', 'blur', 'sharp', 'brightness', 'contrast', 'hue', 'saturation', 'gradient', 'paint', 'draw', 'canvas', 'rembg', 'photoshop', 'gimp']
    
    # è§†é¢‘å¤„ç†ç›¸å…³  
    video_keywords = ['video', 'movie', 'clip', 'frame', 'motion', 'animation', 'gif', 'mp4', 'avi', 'sequence', 'temporal', 'time', 'fps', 'codec', 'stream', 'cinema']
    
    # éŸ³é¢‘å¤„ç†ç›¸å…³
    audio_keywords = ['audio', 'sound', 'music', 'voice', 'speech', 'wav', 'mp3', 'frequency', 'volume', 'pitch', 'noise', 'echo', 'reverb', 'synthesizer', 'beat', 'rhythm']
    
    # AIæ¨¡å‹ç›¸å…³
    ai_keywords = ['model', 'ai', 'ml', 'neural', 'network', 'deep', 'learning', 'train', 'inference', 'classifier', 'detector', 'recognizer', 'gan', 'vae', 'transformer', 'bert', 'gpt', 'llm', 'clip', 'stable', 'diffusion', 'checkpoint', 'lora', 'controlnet', 'ipadapter']
    
    # å·¥å…·ç±»
    tool_keywords = ['tool', 'utility', 'helper', 'manager', 'loader', 'saver', 'converter', 'processor', 'generator', 'creator', 'viewer', 'display', 'preview', 'debug', 'monitor', 'log', 'math', 'calculation', 'random', 'string', 'text', 'number', 'list', 'batch', 'workflow', 'node', 'custom', 'advanced', 'extra', 'extension', 'plugin']
    
    # 3Dç›¸å…³
    threod_keywords = ['3d', 'mesh', 'geometry', 'vertex', 'face', 'normal', 'texture', 'material', 'render', 'lighting', 'camera', 'scene', 'object', 'model', 'blender', 'maya', 'obj', 'fbx', 'gltf']
    
    # æ£€æŸ¥å…³é”®è¯åŒ¹é…
    if any(keyword in text for keyword in image_keywords):
        return 'image'
    elif any(keyword in text for keyword in video_keywords):
        return 'video' 
    elif any(keyword in text for keyword in audio_keywords):
        return 'audio'
    elif any(keyword in text for keyword in ai_keywords):
        return 'ai'
    elif any(keyword in text for keyword in threod_keywords):
        return '3d'
    elif any(keyword in text for keyword in tool_keywords):
        return 'tool'
    else:
        return 'other'

@app.get("/comfyui/status")
async def comfyui_status():
    """æ£€æŸ¥ComfyUIçŠ¶æ€"""
    global comfyui_process
    if comfyui_process and comfyui_process.poll() is None:
        return {"status": "running", "message": "ComfyUIæ­£åœ¨è¿è¡Œ", "pid": comfyui_process.pid}
    else:
        return {"status": "stopped", "message": "ComfyUIæœªè¿è¡Œ"}

@app.post("/comfyui/start")
async def start_comfyui(request: dict = None):
    """å¯åŠ¨ComfyUI"""
    global comfyui_process
    
    # æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨è¿è¡Œ
    if comfyui_process and comfyui_process.poll() is None:
        return {"status": "already_running", "message": "ComfyUIå·²åœ¨è¿è¡Œ", "pid": comfyui_process.pid}
    
    try:
        import subprocess
        import sys
        
        # ä¾¿æºåŒ…ç¯å¢ƒè·¯å¾„æ£€æµ‹
        # å½“å‰æ–‡ä»¶: launcher/backend/start_fixed_cors.py
        # ç›®æ ‡æ–‡ä»¶: ComfyUI/main.py
        paths = get_portable_paths()
        comfyui_dir = paths["comfyui_path"]
        main_py = os.path.join(comfyui_dir, "main.py")
        
        # Convert paths to WSL format if running in WSL
        if os.path.exists('/proc/version'):
            try:
                with open('/proc/version', 'r') as f:
                    if 'microsoft' in f.read().lower():
                        # Running in WSL, convert Windows paths
                        main_py_wsl = main_py.replace('\\', '/').replace('D:', '/mnt/d')
                        comfyui_dir_wsl = comfyui_dir.replace('\\', '/').replace('D:', '/mnt/d')
                        if os.path.exists(main_py_wsl):
                            main_py = main_py_wsl
                            comfyui_dir = comfyui_dir_wsl
            except:
                pass
        
        if not os.path.exists(main_py):
            return {"status": "error", "message": f"æ‰¾ä¸åˆ°ComfyUIä¸»æ–‡ä»¶: {main_py}"}
        
        print(f"Starting ComfyUI from: {main_py}")
        print(f"Working directory: {comfyui_dir}")
        
        # æ£€æŸ¥ä¾¿æºåŒ…è™šæ‹Ÿç¯å¢ƒ
        venv_path = os.path.join(paths["portable_root"], "venv")
        
        # å¯åŠ¨ComfyUIè¿›ç¨‹
        env = os.environ.copy()
        env['PYTHONPATH'] = comfyui_dir
        
        if os.path.exists(venv_path):
            print(f" Found venv at: {venv_path}")
            
            # æŸ¥æ‰¾condaç¯å¢ƒä¸­çš„python
            python_candidates = [
                os.path.join(venv_path, "python.exe"),  # Windows
                os.path.join(venv_path, "Scripts", "python.exe"),  # Windows
                os.path.join(venv_path, "bin", "python"),  # Linux/Mac
            ]
            
            python_exe = None
            for candidate in python_candidates:
                if os.path.exists(candidate):
                    python_exe = candidate
                    # Convert Windows path to WSL path if running in WSL
                    if os.path.exists('/proc/version'):
                        try:
                            with open('/proc/version', 'r') as f:
                                if 'microsoft' in f.read().lower():
                                    # Running in WSL, convert Windows path
                                    wsl_path = candidate.replace('\\', '/').replace('D:', '/mnt/d')
                                    if os.path.exists(wsl_path):
                                        python_exe = wsl_path
                        except:
                            pass
                    break
            
            if python_exe:
                print(f"ğŸ Using conda python: {python_exe}")
                
                # è®¾ç½®condaç¯å¢ƒå˜é‡
                env['CONDA_PREFIX'] = venv_path
                env['CONDA_DEFAULT_ENV'] = venv_path
                
                # æ·»åŠ condaç¯å¢ƒçš„è·¯å¾„åˆ°PATH
                if os.name == 'nt':  # Windows
                    scripts_path = os.path.join(venv_path, "Scripts")
                    library_bin = os.path.join(venv_path, "Library", "bin")
                    env['PATH'] = f"{venv_path};{scripts_path};{library_bin};{env.get('PATH', '')}"
                else:  # Linux/Mac
                    bin_path = os.path.join(venv_path, "bin")
                    env['PATH'] = f"{bin_path}:{env.get('PATH', '')}"
                
                # æ„å»ºå¯åŠ¨å‘½ä»¤ï¼Œæ”¯æŒè‡ªå®šä¹‰å‚æ•°
                # ç¡®ä¿åœ¨subprocessä¸­ä½¿ç”¨Windowsè·¯å¾„æ ¼å¼
                python_exe_win = python_exe.replace('/mnt/d', 'D:').replace('/', '\\') if python_exe.startswith('/mnt/d') else python_exe
                main_py_win = main_py.replace('/mnt/d', 'D:').replace('/', '\\') if main_py.startswith('/mnt/d') else main_py
                cmd = [python_exe_win, main_py_win]
                
                # å¤„ç†è‡ªå®šä¹‰å‚æ•°
                if request:
                    params = request
                else:
                    params = {}
                
                # åŸºæœ¬ç½‘ç»œå‚æ•°
                listen_addr = params.get("listen_address", "127.0.0.1")
                port = str(params.get("port", "8188"))
                cmd.extend(["--listen", listen_addr, "--port", port])
                
                # æ€§èƒ½å‚æ•°
                if params.get("cpu_mode", False):
                    cmd.append("--cpu")
                
                precision = params.get("precision_mode", "fp16")
                if precision == "fp32":
                    cmd.append("--force-fp32")
                elif precision == "bf16":
                    cmd.append("--bf16-unet")
                
                if params.get("dont_upcast_attention", False):
                    cmd.append("--dont-upcast-attention")
                
                # å¼€å‘å‚æ•°
                if params.get("enable_cors_header", False):
                    cmd.append("--enable-cors-header")
                
                if params.get("dont_print_server", False):
                    cmd.append("--dont-print-server")
                
                # è®¾ç½®ä»£ç†ç¯å¢ƒå˜é‡
                proxy_settings = params.get("proxy_settings", {})
                if proxy_settings.get("enabled", False):
                    http_proxy = proxy_settings.get("http_proxy", "")
                    https_proxy = proxy_settings.get("https_proxy", "")
                    
                    if http_proxy:
                        env['HTTP_PROXY'] = http_proxy
                        env['http_proxy'] = http_proxy
                    
                    if https_proxy:
                        env['HTTPS_PROXY'] = https_proxy
                        env['https_proxy'] = https_proxy
                    
                    # è®¾ç½®ä¸ä½¿ç”¨ä»£ç†çš„åœ°å€
                    no_proxy = proxy_settings.get("no_proxy", "localhost,127.0.0.1")
                    if no_proxy:
                        env['NO_PROXY'] = no_proxy
                        env['no_proxy'] = no_proxy
            else:
                print(f"è­¦å‘Š  Conda python not found in {venv_path}, using system python")
                # æ„å»ºå¯åŠ¨å‘½ä»¤ï¼Œæ”¯æŒè‡ªå®šä¹‰å‚æ•°
                # ç¡®ä¿åœ¨subprocessä¸­ä½¿ç”¨Windowsè·¯å¾„æ ¼å¼
                sys_executable_win = sys.executable.replace('/mnt/d', 'D:').replace('/', '\\') if sys.executable.startswith('/mnt/d') else sys.executable
                main_py_win = main_py.replace('/mnt/d', 'D:').replace('/', '\\') if main_py.startswith('/mnt/d') else main_py
                cmd = [sys_executable_win, main_py_win]
                
                # å¤„ç†è‡ªå®šä¹‰å‚æ•°
                if request:
                    params = request
                else:
                    params = {}
                
                # åŸºæœ¬ç½‘ç»œå‚æ•°
                listen_addr = params.get("listen_address", "127.0.0.1")
                port = str(params.get("port", "8188"))
                cmd.extend(["--listen", listen_addr, "--port", port])
                
                # æ€§èƒ½å‚æ•°
                if params.get("cpu_mode", False):
                    cmd.append("--cpu")
                
                precision = params.get("precision_mode", "fp16")
                if precision == "fp32":
                    cmd.append("--force-fp32")
                elif precision == "bf16":
                    cmd.append("--bf16-unet")
                
                if params.get("dont_upcast_attention", False):
                    cmd.append("--dont-upcast-attention")
                
                # å¼€å‘å‚æ•°
                if params.get("enable_cors_header", False):
                    cmd.append("--enable-cors-header")
                
                if params.get("dont_print_server", False):
                    cmd.append("--dont-print-server")
                
                # è®¾ç½®ä»£ç†ç¯å¢ƒå˜é‡
                proxy_settings = params.get("proxy_settings", {})
                if proxy_settings.get("enabled", False):
                    http_proxy = proxy_settings.get("http_proxy", "")
                    https_proxy = proxy_settings.get("https_proxy", "")
                    
                    if http_proxy:
                        env['HTTP_PROXY'] = http_proxy
                        env['http_proxy'] = http_proxy
                    
                    if https_proxy:
                        env['HTTPS_PROXY'] = https_proxy
                        env['https_proxy'] = https_proxy
                    
                    # è®¾ç½®ä¸ä½¿ç”¨ä»£ç†çš„åœ°å€
                    no_proxy = proxy_settings.get("no_proxy", "localhost,127.0.0.1")
                    if no_proxy:
                        env['NO_PROXY'] = no_proxy
                        env['no_proxy'] = no_proxy
        else:
            print(f"è­¦å‘Š  Virtual environment not found at {venv_path}")
            print("Using system python")
            # æ„å»ºå¯åŠ¨å‘½ä»¤ï¼Œæ”¯æŒè‡ªå®šä¹‰å‚æ•°
            # ç¡®ä¿åœ¨subprocessä¸­ä½¿ç”¨Windowsè·¯å¾„æ ¼å¼
            sys_executable_win = sys.executable.replace('/mnt/d', 'D:').replace('/', '\\') if sys.executable.startswith('/mnt/d') else sys.executable
            main_py_win = main_py.replace('/mnt/d', 'D:').replace('/', '\\') if main_py.startswith('/mnt/d') else main_py
            cmd = [sys_executable_win, main_py_win]
            
            # å¤„ç†è‡ªå®šä¹‰å‚æ•°
            if request:
                params = request
            else:
                params = {}
            
            # åŸºæœ¬ç½‘ç»œå‚æ•°
            listen_addr = params.get("listen_address", "127.0.0.1")
            port = str(params.get("port", "8188"))
            cmd.extend(["--listen", listen_addr, "--port", port])
            
            # æ€§èƒ½å‚æ•°
            if params.get("cpu_mode", False):
                cmd.append("--cpu")
            
            precision = params.get("precision_mode", "fp16")
            if precision == "fp32":
                cmd.append("--force-fp32")
            elif precision == "bf16":
                cmd.append("--bf16-unet")
            
            if params.get("dont_upcast_attention", False):
                cmd.append("--dont-upcast-attention")
            
            # å¼€å‘å‚æ•°
            if params.get("enable_cors_header", False):
                cmd.append("--enable-cors-header")
            
            if params.get("dont_print_server", False):
                cmd.append("--dont-print-server")
        
        print(f"ğŸ“ Command: {' '.join(cmd)}")
        print(f"ğŸŒ Environment PATH: {env.get('PATH', '')[:200]}...")
        print(f"ğŸ CONDA_PREFIX: {env.get('CONDA_PREFIX', 'Not set')}")
        
        try:
            # ä½¿ç”¨åŸé¡¹ç›®çš„æ‰¹å¤„ç†æ–‡ä»¶å¯åŠ¨æ–¹å¼ï¼Œä¿®å¤WSLå…¼å®¹æ€§
            start_bat = os.path.join(comfyui_dir, "start_comfyui_service.bat")
            
            # æ£€æŸ¥æ˜¯å¦åœ¨WSLç¯å¢ƒä¸­
            in_wsl = False
            try:
                with open('/proc/version', 'r') as f:
                    if 'microsoft' in f.read().lower():
                        in_wsl = True
            except:
                pass
                
            if os.path.exists(venv_path) and os.path.exists(start_bat):
                print(f" Using batch file: {start_bat}")
                
                if in_wsl:
                    # WSLç¯å¢ƒï¼šä½¿ç”¨cmd.exeè°ƒç”¨Windowsæ‰¹å¤„ç†æ–‡ä»¶
                    start_bat_win = start_bat.replace('/mnt/d', 'D:').replace('/', '\\')
                    print(f" WSL detected, using cmd.exe with: {start_bat_win}")
                    comfyui_process = subprocess.Popen(
                        ["cmd.exe", "/c", start_bat_win],
                        cwd=comfyui_dir,  # ä½¿ç”¨WSLè·¯å¾„ä½œä¸ºå·¥ä½œç›®å½•
                        shell=False
                    )
                else:
                    # åŸç”ŸWindowsç¯å¢ƒ
                    print(f" Windows detected, using CREATE_NEW_CONSOLE")
                    comfyui_process = subprocess.Popen(
                        [start_bat],
                        cwd=comfyui_dir,
                        shell=False,
                        creationflags=0x00000010  # CREATE_NEW_CONSOLE
                    )
            else:
                # å›é€€åˆ°ç›´æ¥Pythonæ‰§è¡Œ
                if start_bat and not os.path.exists(start_bat):
                    print(f"è­¦å‘Š  Batch file not found: {start_bat}")
                if not os.path.exists(venv_path):
                    print(f"è­¦å‘Š  Virtual environment not found: {venv_path}")
                    
                print("è­¦å‘Š  Using direct python execution")
                
                if in_wsl:
                    # WSLç¯å¢ƒä¸­ç›´æ¥ä½¿ç”¨python
                    comfyui_process = subprocess.Popen(
                        cmd,
                        cwd=comfyui_dir,
                        env=env,
                        shell=False
                    )
                else:
                    # Windowsç¯å¢ƒä½¿ç”¨CREATE_NEW_CONSOLE
                    comfyui_process = subprocess.Popen(
                        cmd,
                        cwd=comfyui_dir,
                        env=env,
                        shell=False,
                        creationflags=0x00000010  # CREATE_NEW_CONSOLE
                    )
            
            print(f"Process started with PID: {comfyui_process.pid}")
            
            # ç­‰å¾…è¿›ç¨‹åˆå§‹åŒ–
            await asyncio.sleep(2)
            
            # æ£€æŸ¥è¿›ç¨‹æ˜¯å¦è¿˜åœ¨è¿è¡Œ
            if comfyui_process.poll() is None:
                print("ComfyUI process is running")
                
                # ç­‰å¾…ComfyUIå®Œå…¨å¯åŠ¨å¹¶é‡è¯•æ£€æŸ¥WebæœåŠ¡
                print("Waiting for ComfyUI to fully initialize...")
                
                max_retries = 6  # æœ€å¤šé‡è¯•6æ¬¡ï¼Œæ€»è®¡çº¦30ç§’
                for attempt in range(max_retries):
                    await asyncio.sleep(5)  # æ¯æ¬¡ç­‰å¾…5ç§’
                    
                    # æ£€æŸ¥è¿›ç¨‹æ˜¯å¦è¿˜åœ¨è¿è¡Œ
                    if comfyui_process.poll() is not None:
                        print(f"ERROR Process exited during initialization (attempt {attempt + 1})")
                        break
                    
                    print(f" Checking web service availability (attempt {attempt + 1}/{max_retries})...")
                    
                    # æ£€æŸ¥WebæœåŠ¡æ˜¯å¦å¯ç”¨
                    try:
                        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        sock.settimeout(3)
                        result = sock.connect_ex(('127.0.0.1', 8188))
                        sock.close()
                        
                        if result == 0:
                            print(" ComfyUI web service is accessible!")
                            return {
                                "status": "running", 
                                "message": "ComfyUIå¯åŠ¨æˆåŠŸå¹¶å¯è®¿é—®ï¼", 
                                "pid": comfyui_process.pid,
                                "url": "http://127.0.0.1:8188",
                                "web_status": "accessible",
                                "startup_time": f"{(attempt + 1) * 5} seconds"
                            }
                        else:
                            print(f"Web service not ready, waiting... (attempt {attempt + 1})")
                            
                    except Exception as e:
                        print(f"Connection test failed: {e} (attempt {attempt + 1})")
                
                # æ‰€æœ‰é‡è¯•éƒ½å®Œæˆäº†
                if comfyui_process.poll() is None:
                    print("è­¦å‘Š  ComfyUI process is running but web service may still be starting")
                    return {
                        "status": "starting", 
                        "message": "ComfyUIè¿›ç¨‹å·²å¯åŠ¨ï¼ŒWebæœåŠ¡å¯èƒ½è¿˜éœ€è¦æ›´å¤šæ—¶é—´åˆå§‹åŒ–", 
                        "pid": comfyui_process.pid,
                        "url": "http://127.0.0.1:8188",
                        "web_status": "initializing",
                        "note": "è¯·ç­‰å¾…1-2åˆ†é’Ÿåå†å°è¯•è®¿é—®"
                    }
                else:
                    print("ERROR Process exited during initialization")
                    return {
                        "status": "failed",
                        "message": "ComfyUIåœ¨åˆå§‹åŒ–è¿‡ç¨‹ä¸­é€€å‡º",
                        "error": "Process exited unexpectedly",
                        "note": "è¯·æ£€æŸ¥ComfyUIæ§åˆ¶å°çª—å£çš„é”™è¯¯ä¿¡æ¯"
                    }
            else:
                # è¿›ç¨‹å·²é€€å‡º
                print(f"âœ— Process exited with code: {comfyui_process.returncode}")
                
                return {
                    "status": "failed", 
                    "message": f"ComfyUIå¯åŠ¨å¤±è´¥ (exit code: {comfyui_process.returncode})",
                    "error": "Process exited immediately",
                    "note": "è¯·æ£€æŸ¥ComfyUIæ§åˆ¶å°çª—å£çš„é”™è¯¯ä¿¡æ¯",
                    "exit_code": comfyui_process.returncode or -1
                }
                
        except Exception as proc_error:
            print(f"âœ— Failed to start process: {proc_error}")
            return {"status": "error", "message": f"è¿›ç¨‹å¯åŠ¨å¼‚å¸¸: {str(proc_error)}"}
            
    except Exception as e:
        return {"status": "error", "message": f"å¯åŠ¨å¤±è´¥: {str(e)}"}

@app.post("/comfyui/stop")
async def stop_comfyui():
    """åœæ­¢ComfyUI"""
    global comfyui_process
    
    if not comfyui_process:
        return {"status": "not_running", "message": "ComfyUIæœªè¿è¡Œ"}
    
    try:
        if comfyui_process.poll() is None:
            comfyui_process.terminate()
            
            # ç­‰å¾…è¿›ç¨‹ç»“æŸ
            try:
                comfyui_process.wait(timeout=10)
            except subprocess.TimeoutExpired:
                # å¼ºåˆ¶æ€æ­»è¿›ç¨‹
                comfyui_process.kill()
                comfyui_process.wait()
            
            comfyui_process = None
            return {"status": "stopped", "message": "ComfyUIå·²åœæ­¢"}
        else:
            comfyui_process = None
            return {"status": "already_stopped", "message": "ComfyUIå·²ç»åœæ­¢"}
            
    except Exception as e:
        return {"status": "error", "message": f"åœæ­¢å¤±è´¥: {str(e)}"}

@app.get("/comfyui/logs")
async def get_comfyui_logs():
    """è·å–ComfyUIæ—¥å¿—"""
    global comfyui_process
    
    if not comfyui_process:
        return {"status": "not_running", "logs": "ComfyUIæœªè¿è¡Œ"}
    
    try:
        # ä¸å†é‡å®šå‘è¾“å‡ºï¼Œæ—¥å¿—åœ¨ComfyUIçš„æ§åˆ¶å°çª—å£ä¸­æ˜¾ç¤º
        if comfyui_process.poll() is None:
            return {
                "status": "running", 
                "logs": f"ComfyUIæ­£åœ¨è¿è¡Œ (PID: {comfyui_process.pid})\næ—¥å¿—æ˜¾ç¤ºåœ¨ComfyUIæ§åˆ¶å°çª—å£ä¸­\næˆ–è®¿é—®: http://127.0.0.1:8188",
                "pid": comfyui_process.pid
            }
        else:
            return {
                "status": "stopped", 
                "logs": "ComfyUIè¿›ç¨‹å·²åœæ­¢\næ—¥å¿—ä¿¡æ¯è¯·æŸ¥çœ‹ComfyUIæ§åˆ¶å°çª—å£"
            }
            
    except Exception as e:
        return {"status": "error", "logs": f"è¯»å–æ—¥å¿—å¤±è´¥: {str(e)}"}

@app.get("/comfyui/check")
async def check_comfyui_web():
    """æ£€æŸ¥ComfyUI WebæœåŠ¡æ˜¯å¦å¯è®¿é—®"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(2)
        result = sock.connect_ex(('127.0.0.1', 8188))
        sock.close()
        
        if result == 0:
            return {
                "status": "accessible",
                "message": "ComfyUI WebæœåŠ¡å¯è®¿é—®",
                "url": "http://127.0.0.1:8188"
            }
        else:
            return {
                "status": "not_accessible",
                "message": "ComfyUI WebæœåŠ¡æš‚ä¸å¯è®¿é—®",
                "url": "http://127.0.0.1:8188"
            }
    except Exception as e:
        return {
            "status": "error",
            "message": f"æ£€æŸ¥å¤±è´¥: {str(e)}"
        }

@app.get("/comfyui/queue")
async def get_comfyui_queue():
    """ä»£ç†ComfyUIé˜Ÿåˆ—çŠ¶æ€APIï¼Œè§£å†³CORSé—®é¢˜"""
    try:
        import urllib.request
        import json

        # ç›´æ¥è®¿é—®ComfyUIçš„é˜Ÿåˆ—API
        with urllib.request.urlopen('http://127.0.0.1:8188/queue', timeout=5) as response:
            data = json.loads(response.read().decode())
            return data
    except Exception as e:
        return {
            "status": "error",
            "message": f"è·å–é˜Ÿåˆ—çŠ¶æ€å¤±è´¥: {str(e)}",
            "queue_running": [],
            "queue_pending": []
        }

# Gitä»“åº“è¾…åŠ©å‡½æ•°
def get_git_repo():
    """è·å–ComfyUI Gitä»“åº“å¯¹è±¡ï¼Œå¦‚æœä¸æ˜¯æœ‰æ•ˆä»“åº“åˆ™è¿”å›None"""
    try:
        import git
        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        comfyui_dir = paths["comfyui_path"]
        
        try:
            return git.Repo(comfyui_dir), comfyui_dir
        except git.exc.InvalidGitRepositoryError:
            return None, comfyui_dir
    except ImportError:
        return None, None

# Gitç‰ˆæœ¬ç®¡ç†API
@app.get("/git/status")
async def git_status():
    """è·å–Gitä»“åº“çŠ¶æ€"""
    try:
        repo, comfyui_dir = get_git_repo()
        if repo is None:
            return {
                "status": "error",
                "message": f"ç›®å½• {comfyui_dir} ä¸æ˜¯æœ‰æ•ˆçš„Gitä»“åº“"
            }
        
        # è·å–å½“å‰åˆ†æ”¯
        current_branch = repo.active_branch.name
        
        # è·å–æœ€æ–°æäº¤ä¿¡æ¯
        latest_commit = repo.head.commit
        commit_info = {
            "hash": latest_commit.hexsha[:8],
            "message": latest_commit.message.strip(),
            "author": str(latest_commit.author),
            "date": latest_commit.committed_datetime.strftime("%Y-%m-%d %H:%M:%S")
        }
        
        # æ£€æŸ¥æ˜¯å¦æœ‰æœªæäº¤çš„æ›´æ”¹
        is_dirty = repo.is_dirty()
        
        # è·å–æ‰€æœ‰åˆ†æ”¯
        branches = [ref.name for ref in repo.heads]
        
        # è·å–è¿œç¨‹çŠ¶æ€
        try:
            origin = repo.remotes.origin
            behind_count = len(list(repo.iter_commits(f'{current_branch}..origin/{current_branch}')))
            ahead_count = len(list(repo.iter_commits(f'origin/{current_branch}..{current_branch}')))
        except:
            behind_count = 0
            ahead_count = 0
        
        return {
            "status": "success",
            "current_branch": current_branch,
            "commit": commit_info,
            "is_dirty": is_dirty,
            "branches": branches,
            "behind_count": behind_count,
            "ahead_count": ahead_count
        }
        
    except Exception as e:
        return {
            "status": "error",
            "message": f"GitçŠ¶æ€è·å–å¤±è´¥: {str(e)}"
        }

@app.get("/git/commits")
async def git_commits():
    """è·å–æäº¤å†å² - é«˜é€Ÿæœ¬åœ°Gitç‰ˆæœ¬"""
    try:
        import subprocess
        import time
        
        start_time = time.time()
        print("ä½¿ç”¨é«˜é€Ÿæœ¬åœ°Gitè·å–æäº¤å†å²...")
        
        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        comfyui_dir = paths["comfyui_path"]
        
        # è·å–å½“å‰æäº¤
        try:
            current_commit = subprocess.check_output(
                ['git', 'rev-parse', '--short', 'HEAD'],
                cwd=comfyui_dir,
                encoding='utf-8',
                errors='ignore',
                timeout=5
            ).strip()
            print(f"å½“å‰æäº¤: {current_commit}")
        except Exception as e:
            print(f"è·å–å½“å‰æäº¤å¤±è´¥: {e}")
            current_commit = None
            
        # è·å–æäº¤å†å² - åªè·å–å½“å‰åˆ†æ”¯ï¼Œé¿å…å¤æ‚æ“ä½œ
        try:
            git_log = subprocess.check_output(
                ['git', 'log', '--pretty=format:%h|%s|%ci|%an', '-100'],
                cwd=comfyui_dir,
                encoding='utf-8',
                errors='ignore',
                timeout=10
            )
            print(f"Gitå‘½ä»¤æ‰§è¡ŒæˆåŠŸï¼Œç”¨æ—¶: {time.time() - start_time:.2f}ç§’")
        except Exception as e:
            print(f"Gitæ—¥å¿—è·å–å¤±è´¥: {e}")
            return {
                "status": "error", 
                "message": f"Gitæ—¥å¿—è·å–å¤±è´¥: {str(e)}"
            }

        # è§£ææäº¤å†å²
        commits = []
        for line in git_log.strip().split('\n'):
            if not line:
                continue
                
            parts = line.split('|')
            if len(parts) >= 4:
                commit_hash, message, date, author = parts[0], parts[1], parts[2], parts[3]
                is_current = (commit_hash == current_commit)
                
                commits.append({
                    "hash": commit_hash,
                    "full_hash": commit_hash,  # ç®€åŒ–ï¼Œä½¿ç”¨çŸ­hash
                    "message": message.strip(),
                    "author": author.strip(),
                    "date": date.strip(),
                    "is_current": is_current
                })
        
        end_time = time.time()
        print(f"Gitæäº¤å†å²è·å–å®Œæˆï¼Œå…±{len(commits)}ä¸ªæäº¤ï¼Œæ€»ç”¨æ—¶: {end_time - start_time:.2f}ç§’")
        
        return {
            "status": "success",
            "commits": commits
        }
        
    except Exception as e:
        return {
            "status": "error",
            "message": f"æäº¤å†å²è·å–å¤±è´¥: {str(e)}"
        }

@app.get("/git/current-commit")
async def get_current_commit():
    """è·å–å½“å‰Gitæäº¤å“ˆå¸Œ"""
    try:
        import git
        paths = get_portable_paths()
        comfyui_dir = paths["comfyui_path"]
        
        repo = git.Repo(comfyui_dir)
        current_commit = repo.head.commit.hexsha
        
        return {
            "status": "success",
            "commit_hash": current_commit,
            "commit_short": current_commit[:8],
            "commit_message": repo.head.commit.message.strip(),
            "commit_date": repo.head.commit.committed_datetime.strftime("%Y-%m-%d %H:%M:%S")
        }
        
    except Exception as e:
        return {
            "status": "error",
            "message": f"è·å–å½“å‰æäº¤å¤±è´¥: {str(e)}"
        }

@app.get("/comfyui/versions")
async def get_comfyui_versions(force_refresh: bool = False):
    """è·å–ComfyUIç‰ˆæœ¬ä¿¡æ¯ï¼ˆä»è¿œç¨‹ä»“åº“ï¼‰"""
    global version_cache, version_cache_expiry

    try:
        import requests
        from datetime import datetime
        import git

        # è·å–å½“å‰Gitæäº¤å“ˆå¸Œï¼Œç”¨äºæ ‡è¯†å½“å‰ç‰ˆæœ¬
        current_commit_hash = None
        try:
            paths = get_portable_paths()
            comfyui_dir = paths["comfyui_path"]
            print(f"æ£€æŸ¥ComfyUIç›®å½•: {comfyui_dir}")
            if os.path.exists(os.path.join(comfyui_dir, ".git")):
                repo = git.Repo(comfyui_dir)
                current_commit_hash = repo.head.commit.hexsha
                current_branch = repo.active_branch.name if not repo.head.is_detached else "detached"
                print(f"å½“å‰ComfyUIçŠ¶æ€:")
                print(f"  - åˆ†æ”¯: {current_branch}")
                print(f"  - æäº¤å“ˆå¸Œ: {current_commit_hash}")
                print(f"  - çŸ­å“ˆå¸Œ: {current_commit_hash[:8]}")
            else:
                print("ComfyUIç›®å½•ä¸æ˜¯Gitä»“åº“ï¼Œæ— æ³•è·å–å½“å‰ç‰ˆæœ¬")
        except Exception as e:
            print(f"è·å–å½“å‰Gitæäº¤å¤±è´¥: {e}")
            current_commit_hash = None

        # æ£€æŸ¥ç¼“å­˜ï¼ˆé™¤éå¼ºåˆ¶åˆ·æ–°ï¼‰
        now = datetime.now()
        if not force_refresh and version_cache and version_cache_expiry and now < version_cache_expiry:
            print("Returning cached version data")
            return version_cache
        
        if force_refresh:
            print("å¼ºåˆ¶åˆ·æ–°ç‰ˆæœ¬æ•°æ®ï¼Œè·³è¿‡ç¼“å­˜")

        print("ä¼˜å…ˆä½¿ç”¨æœ¬åœ°Gitè·å–ç‰ˆæœ¬æ•°æ®ï¼ˆå¿«é€Ÿæ¨¡å¼ï¼‰")

        #  ä¼˜å…ˆä½¿ç”¨æœ¬åœ°Gitä»“åº“è·å–æ•°æ®ï¼ˆé€Ÿåº¦æœ€å¿«ï¼‰
        try:
            # å¯¼å…¥æœ¬åœ°ç‰ˆæœ¬ç®¡ç†å™¨
            import sys
            import os
            backend_dir = os.path.dirname(__file__)
            core_dir = os.path.join(backend_dir, 'core')
            if core_dir not in sys.path:
                sys.path.insert(0, core_dir)
            
            from version_manager import VersionManager
            
            # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„åˆå§‹åŒ–ç‰ˆæœ¬ç®¡ç†å™¨
            paths = get_portable_paths()
            comfyui_dir = paths["comfyui_path"]
            version_mgr = VersionManager(comfyui_dir)
            
            if version_mgr.is_git_repo():
                print(f"ä½¿ç”¨æœ¬åœ°Gitä»“åº“è·å–ç‰ˆæœ¬æ•°æ®: {comfyui_dir}")
                
                # å¿«é€Ÿè·å–ç‰ˆæœ¬å†å²ï¼ˆæœ€å¤š30ä¸ªæäº¤ï¼‰
                local_versions = version_mgr.get_version_history(limit=30)
                current_version = version_mgr.get_current_version()
                
                # æ„é€ å¼€å‘ç‰ˆæœ¬æ•°æ®
                development_versions = []
                for i, version in enumerate(local_versions):
                    development_versions.append({
                        'id': version.commit_hash,
                        'version': f'dev-{version.commit_hash}',
                        'date': version.date.strftime('%Y-%m-%dT%H:%M:%SZ'),
                        'isCurrent': version.is_current,
                        'commit': version.commit_hash,
                        'message': version.commit_message.split('\n')[0][:100],  # å–ç¬¬ä¸€è¡Œå¹¶é™åˆ¶é•¿åº¦
                        'author': version.author
                    })
                
                print(f"æœ¬åœ°Gitå¿«é€Ÿè·å– {len(local_versions)} ä¸ªç‰ˆæœ¬ï¼Œè€—æ—¶æçŸ­")
                
                # ä½¿ç”¨æœ¬åœ°Gitä¿¡æ¯åˆ›å»ºåŸºæœ¬çš„repo_data
                repo_data = {
                    "name": "ComfyUI",
                    "full_name": "comfyanonymous/ComfyUI", 
                    "description": "æœ¬åœ°Gitä»“åº“",
                    "html_url": "https://github.com/comfyanonymous/ComfyUI"
                }
                
                # å¿«é€Ÿè·å–ç¨³å®šç‰ˆæœ¬ï¼ˆæ ‡ç­¾ï¼‰
                stable_versions = []
                try:
                    tags = version_mgr.get_tags_with_info()
                    for tag in tags[:15]:  # åªå–å‰15ä¸ªæœ€æ–°æ ‡ç­¾
                        stable_versions.append({
                            'id': tag.name,
                            'version': tag.name,
                            'date': tag.date.strftime('%Y-%m-%dT%H:%M:%SZ'),
                            'isCurrent': tag.is_current,
                            'commit': tag.commit_hash,
                            'message': tag.message.split('\n')[0][:100],
                            'author': tag.author
                        })
                    print(f"æœ¬åœ°Gitå¿«é€Ÿè·å– {len(stable_versions)} ä¸ªç¨³å®šç‰ˆæœ¬")
                except Exception as e:
                    print(f"è·å–æœ¬åœ°æ ‡ç­¾å¤±è´¥: {e}")
                
                # å¿«é€Ÿæ¨¡å¼ï¼šç›´æ¥è·³è½¬åˆ°ç»“æœæ„å»º
                print(" æœ¬åœ°Gitå¿«é€Ÿæ¨¡å¼å®Œæˆï¼Œè·³è¿‡è¿œç¨‹APIè°ƒç”¨")
                
                # è·å–å½“å‰GitçŠ¶æ€
                current_branch = "unknown"
                current_commit = "unknown"
                if current_version:
                    current_commit = current_version.commit_hash
                try:
                    current_branch = version_mgr.repo.active_branch.name if not version_mgr.repo.head.is_detached else "detached"
                except:
                    current_branch = "detached"
                
                result = {
                    "status": "success",
                    "current_branch": current_branch,
                    "current_commit": current_commit,
                    "stable": stable_versions,
                    "development": development_versions
                }
                
                # ç¼“å­˜ç»“æœ
                from datetime import timedelta
                version_cache = result
                version_cache_expiry = now + timedelta(minutes=10)
                
                print(f"=== æœ¬åœ°Gitå¿«é€Ÿæ¨¡å¼ç»“æœ ===")
                print(f"å½“å‰åˆ†æ”¯: {current_branch}")
                print(f"å½“å‰æäº¤: {current_commit}")
                print(f"ç¨³å®šç‰ˆæœ¬æ•°é‡: {len(stable_versions)}")
                print(f"å¼€å‘ç‰ˆæœ¬æ•°é‡: {len(development_versions)}")
                
                return result
            else:
                print("ComfyUIç›®å½•ä¸æ˜¯æœ‰æ•ˆçš„Gitä»“åº“ï¼Œå°è¯•è¿œç¨‹API...")
                
        except Exception as e:
            print(f"æœ¬åœ°Gitå¿«é€Ÿæ¨¡å¼å¤±è´¥: {e}ï¼Œå°è¯•è¿œç¨‹API...")

        # ğŸŒ å¤‡ç”¨æ–¹æ¡ˆï¼šè¿œç¨‹APIï¼ˆè¾ƒæ…¢ï¼‰
        print("ä½¿ç”¨è¿œç¨‹APIè·å–ç‰ˆæœ¬æ•°æ®ï¼ˆå¤‡ç”¨æ¨¡å¼ï¼‰")
        
        # è¿œç¨‹APIè·å–é€»è¾‘
        mirrors = [
            "https://api.github.com/repos/comfyanonymous/ComfyUI"
        ]

        repo_data = None
        for mirror_url in mirrors:
            for attempt in range(2):  # å‡å°‘é‡è¯•æ¬¡æ•°
                try:
                    print(f"Trying to fetch from: {mirror_url} (attempt {attempt + 1}/2)")
                    response = requests.get(mirror_url, timeout=3)  # å‡å°‘è¶…æ—¶æ—¶é—´
                    if response.status_code == 200:
                        repo_data = response.json()
                        print(f"Successfully fetched from: {mirror_url}")
                        break
                    else:
                        print(f"HTTP {response.status_code} from {mirror_url}")
                except Exception as e:
                    print(f"Failed to fetch from {mirror_url} (attempt {attempt + 1}): {e}")
                    if attempt < 1:
                        import time
                        time.sleep(0.5)  # å‡å°‘ç­‰å¾…æ—¶é—´
                        continue

            if repo_data:
                break

        if not repo_data:
            return {"status": "error", "message": "æ— æ³•ä»è¿œç¨‹ä»“åº“è·å–ç‰ˆæœ¬ä¿¡æ¯ï¼Œä¸”æœ¬åœ°Gitä¸å¯ç”¨"}

        # è·å–è¿œç¨‹æäº¤æ•°æ®ï¼ˆç®€åŒ–ç‰ˆï¼‰
        commits_data = []
        commits_url = "https://api.github.com/repos/comfyanonymous/ComfyUI/commits"
        
        try:
            print(f"Fetching commits from: {commits_url}")
            # åªè·å–1é¡µï¼Œå‡å°‘APIè°ƒç”¨
            response = requests.get(f"{commits_url}?per_page=30&page=1", timeout=3)
            if response.status_code == 200:
                commits_data = response.json()
                print(f"è·å–åˆ° {len(commits_data)} ä¸ªè¿œç¨‹æäº¤")
            else:
                print(f"è·å–æäº¤å¤±è´¥: HTTP {response.status_code}")
        except Exception as e:
            print(f"è·å–è¿œç¨‹æäº¤å¤±è´¥: {e}")
            commits_data = []

        # è·å–ç¨³å®šç‰ˆæœ¬ä¿¡æ¯ - ä¼˜å…ˆä»GitHubæ ‡ç­¾è·å–ï¼Œç„¶åä»æäº¤è®°å½•è¡¥å……
        stable_versions = []

        # æ–¹æ³•1ï¼šä¼˜å…ˆä»GitHubæ ‡ç­¾è·å–ç¨³å®šç‰ˆæœ¬ï¼ˆè¿™æ˜¯ComfyUIçš„ä¸»è¦å‘å¸ƒæ–¹å¼ï¼‰
        print("Fetching stable versions from GitHub tags...")
        try:
            github_tags_url = "https://api.github.com/repos/comfyanonymous/ComfyUI/tags"
            print(f"Fetching tags from GitHub: {github_tags_url}")

            tags_response = requests.get(github_tags_url, timeout=5)
            if tags_response.status_code == 200:
                tags_data = tags_response.json()
                print(f"Successfully fetched {len(tags_data)} tags from GitHub")

                # è·å–å‰20ä¸ªæ ‡ç­¾ï¼ˆç¡®ä¿æœ‰è¶³å¤Ÿçš„ç‰ˆæœ¬ï¼‰
                for tag in tags_data[:20]:
                    tag_name = tag.get('name', 'unknown')
                    if tag_name.startswith('v') and len(tag_name.split('.')) >= 3:  # ç¡®ä¿æ˜¯ç‰ˆæœ¬æ ¼å¼
                        # æ£€æŸ¥æ˜¯å¦ä¸ºå½“å‰ç‰ˆæœ¬
                        tag_commit_sha = tag.get('commit', {}).get('sha', 'unknown')
                        is_current = current_commit_hash and current_commit_hash.startswith(tag_commit_sha[:8])

                        if is_current:
                            print(f"æ‰¾åˆ°å½“å‰æ ‡ç­¾ç‰ˆæœ¬: {tag_name} - å½“å‰: {current_commit_hash[:8]} vs æ ‡ç­¾: {tag_commit_sha[:8]}")

                        # ä¼˜åŒ–ï¼šç›´æ¥ä»å·²æœ‰çš„commits_dataä¸­æŸ¥æ‰¾ï¼Œé¿å…é¢å¤–APIè°ƒç”¨
                        tag_date = "unknown"
                        if commits_data and tag_commit_sha != 'unknown':
                            for commit in commits_data:
                                if commit.get('sha', '').startswith(tag_commit_sha[:8]):
                                    tag_date = commit.get('commit', {}).get('author', {}).get('date', 'unknown')
                                    break
                        
                        # å¦‚æœè¿˜æ˜¯æ²¡æ‰¾åˆ°ï¼Œä½¿ç”¨ç®€å•çš„æ—¥æœŸæ ¼å¼
                        if tag_date == "unknown":
                            tag_date = "2024-01-01T00:00:00Z"  # é»˜è®¤æ—¥æœŸ

                        stable_versions.append({
                            "id": tag_name,
                            "version": tag_name,
                            "date": tag_date,
                            "isCurrent": is_current,
                            "commit": tag_commit_sha[:8] if tag_commit_sha != 'unknown' else 'unknown',
                            "message": f"Release {tag_name}",
                            "author": "ComfyAnonymous"
                        })

                        # è·å–è¶³å¤Ÿçš„ç‰ˆæœ¬å°±åœæ­¢
                        if len(stable_versions) >= 15:
                            break
            else:
                print(f"Failed to fetch GitHub tags: {tags_response.status_code}")
        except Exception as e:
            print(f"Error fetching GitHub tags: {e}")

        print(f"Found {len(stable_versions)} stable versions from GitHub tags")

        # ğŸš¨ ä¸´æ—¶è§£å†³æ–¹æ¡ˆï¼šå¦‚æœGitHub APIè¢«é™åˆ¶ï¼Œä½¿ç”¨å¤‡ç”¨ç‰ˆæœ¬æ•°æ®
        if len(stable_versions) == 0:
            print("GitHub API rate limited, using fallback version data...")
            fallback_versions = [
                {
                    'version': 'v0.3.45',
                    'id': '9a470e07',
                    'commit': '9a470e07',
                    'date': '2024-07-21T18:58:00Z',
                    'author': 'ComfyAnonymous',
                    'message': 'ComfyUI version v0.3.45'
                },
                {
                    'version': 'v0.3.44',
                    'id': 'c5de4955',
                    'commit': 'c5de4955',
                    'date': '2024-07-08T13:42:00Z',
                    'author': 'ComfyAnonymous',
                    'message': 'ComfyUI version v0.3.44'
                },
                {
                    'version': 'v0.3.43',
                    'id': 'e18f53cc',
                    'commit': 'e18f53cc',
                    'date': '2024-06-27T21:41:00Z',
                    'author': 'ComfyAnonymous',
                    'message': 'ComfyUI version v0.3.43'
                },
                {
                    'version': 'v0.3.42',
                    'id': '6493709d',
                    'commit': '6493709d',
                    'date': '2024-06-26T16:17:00Z',
                    'author': 'ComfyAnonymous',
                    'message': 'ComfyUI version v0.3.42'
                },
                {
                    'version': 'v0.3.41',
                    'id': '483b3e62',
                    'commit': '483b3e62',
                    'date': '2024-06-17T04:00:00Z',
                    'author': 'ComfyAnonymous',
                    'message': 'ComfyUI version v0.3.41'
                },
                {
                    'version': 'v0.3.40',
                    'id': '866f6cda',
                    'commit': '866f6cda',
                    'date': '2024-06-05T02:54:00Z',
                    'author': 'ComfyAnonymous',
                    'message': 'ComfyUI version v0.3.40'
                },
                {
                    'version': 'v0.3.39',
                    'id': '094306b6',
                    'commit': '094306b6',
                    'date': '2024-05-29T18:51:00Z',
                    'author': 'ComfyAnonymous',
                    'message': 'ComfyUI version v0.3.39'
                },
                {
                    'version': 'v0.3.38',
                    'id': 'e6609dac',
                    'commit': 'e6609dac',
                    'date': '2024-05-28T06:40:00Z',
                    'author': 'ComfyAnonymous',
                    'message': 'ComfyUI version v0.3.38'
                },
                {
                    'version': 'v0.3.37',
                    'id': 'c9e1821a',
                    'commit': 'c9e1821a',
                    'date': '2024-05-27T12:07:00Z',
                    'author': 'ComfyAnonymous',
                    'message': 'ComfyUI version v0.3.37'
                },
                {
                    'version': 'v0.3.36',
                    'id': 'ad3bd8aa',
                    'commit': 'ad3bd8aa',
                    'date': '2024-05-24T21:51:00Z',
                    'author': 'ComfyAnonymous',
                    'message': 'ComfyUI version v0.3.36'
                }
            ]
            stable_versions.extend(fallback_versions)
            print(f"Added {len(fallback_versions)} fallback versions")

        # æ–¹æ³•2ï¼šå¦‚æœGitHubæ ‡ç­¾ä¸è¶³ï¼Œä»æäº¤è®°å½•ä¸­è¡¥å……
        if len(stable_versions) < 10 and commits_data:
            print(f"Only found {len(stable_versions)} versions from GitHub tags, supplementing from commit history...")
            existing_versions = {v['version'] for v in stable_versions}
            # ä»æäº¤è®°å½•ä¸­æŸ¥æ‰¾ç‰ˆæœ¬å‘å¸ƒæäº¤ï¼ˆä½œä¸ºGitHubæ ‡ç­¾çš„è¡¥å……ï¼‰
            import re

            print("Debug: First 5 commit messages:")
            for i, commit in enumerate(commits_data[:5]):
                message = commit.get('commit', {}).get('message', '') or commit.get('message', '')
                print(f"  {i+1}. {message[:80]}...")

            # ç®€åŒ–çš„ç‰ˆæœ¬åŒ¹é…æ¨¡å¼ï¼ˆåªä½œä¸ºè¡¥å……ï¼‰
            version_patterns = [
                (re.compile(r'ComfyUI version v?(\d+\.\d+\.\d+)', re.IGNORECASE), "ComfyUI"),
                (re.compile(r'version v?(\d+\.\d+\.\d+)', re.IGNORECASE), "Version"),
            ]

            for commit in commits_data:
                try:
                    commit_message = commit.get('commit', {}).get('message', '') or commit.get('message', '')

                    # åªæŸ¥æ‰¾æ˜ç¡®çš„ç‰ˆæœ¬å‘å¸ƒæäº¤
                    if 'comfyui version' not in commit_message.lower():
                        continue

                    # ç®€å•çš„ç‰ˆæœ¬åŒ¹é…ï¼ˆåªä½œä¸ºè¡¥å……ï¼‰
                    for pattern, pattern_type in version_patterns:
                        version_match = pattern.search(commit_message)
                        if version_match:
                            version_number = version_match.group(1)
                            version_tag = f"v{version_number}"

                            # é¿å…é‡å¤ç‰ˆæœ¬
                            if version_tag in existing_versions:
                                continue
                            existing_versions.add(version_tag)

                            # æå–æäº¤ä¿¡æ¯
                            commit_sha = commit.get('sha', 'unknown')[:8]
                            commit_date = commit.get('commit', {}).get('author', {}).get('date', 'unknown')
                            commit_author = commit.get('commit', {}).get('author', {}).get('name', 'unknown')

                            # æ£€æŸ¥æ˜¯å¦ä¸ºå½“å‰ç‰ˆæœ¬
                            full_commit_sha = commit.get('sha', 'unknown')
                            is_current = current_commit_hash and current_commit_hash.startswith(full_commit_sha[:8])

                            if is_current:
                                print(f"æ‰¾åˆ°å½“å‰ç¨³å®šç‰ˆæœ¬: {version_tag} (æäº¤: {commit_sha}) - å½“å‰: {current_commit_hash[:8]} vs è¿œç¨‹: {full_commit_sha[:8]}")

                            stable_versions.append({
                                "id": version_tag,
                                "version": version_tag,
                                "date": commit_date,
                                "isCurrent": is_current,
                                "commit": commit_sha,
                                "message": f"ComfyUI Release {version_tag}",
                                "author": commit_author
                            })

                            print(f"Found version {version_tag} from commit history")
                            break

                    # é™åˆ¶è¡¥å……ç‰ˆæœ¬æ•°é‡
                    if len(stable_versions) >= 15:
                        break

                except Exception as e:
                    print(f"Error processing commit for version extraction: {e}")
                    continue

        print(f"Final stable versions count: {len(stable_versions)}")

        # è·å–æœ€è¿‘çš„æäº¤ï¼ˆå¼€å‘ç‰ˆæœ¬ï¼‰- ä½¿ç”¨å·²è·å–çš„æäº¤æ•°æ®
        development_versions = []

        # æ”¶é›†æ‰€æœ‰ç¨³å®šç‰ˆæœ¬çš„æäº¤å“ˆå¸Œï¼Œé¿å…é‡å¤
        stable_commit_hashes = set()
        for stable_version in stable_versions:
            commit_hash = stable_version.get('commit', '')
            if commit_hash:
                stable_commit_hashes.add(commit_hash)

        print(f"ç¨³å®šç‰ˆæœ¬æäº¤å“ˆå¸Œ: {stable_commit_hashes}")

        # è°ƒè¯•ï¼šæ£€æŸ¥commits_dataçŠ¶æ€
        print(f"=== å¼€å‘ç‰ˆæœ¬è°ƒè¯•ä¿¡æ¯ ===")
        print(f"commits_dataæ˜¯å¦å­˜åœ¨: {commits_data is not None}")
        if commits_data:
            print(f"commits_dataé•¿åº¦: {len(commits_data)}")
            print(f"å‰3ä¸ªæäº¤:")
            for i, commit in enumerate(commits_data[:3]):
                commit_sha = commit.get('sha', 'unknown')[:8] if commit.get('sha') else 'unknown'
                commit_message = commit.get('commit', {}).get('message', 'No message')[:50]
                print(f"  {i+1}. {commit_sha} - {commit_message}")
        else:
            print("commits_dataä¸ºç©ºï¼è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæ²¡æœ‰å¼€å‘ç‰ˆæœ¬çš„åŸå› ")

        if commits_data:
            for commit in commits_data:
                try:
                    # é€‚é…Giteeå’ŒGitHub APIæ ¼å¼
                    if 'sha' in commit:
                        # GitHub APIæ ¼å¼
                        commit_sha = commit['sha'][:8]
                        commit_info = commit.get('commit', {})
                        author_info = commit_info.get('author', {})
                        commit_date = author_info.get('date', 'unknown')
                        commit_author = author_info.get('name', 'unknown')
                        commit_message = commit_info.get('message', 'No message')
                    else:
                        # Gitee APIæ ¼å¼å¯èƒ½ä¸åŒ
                        commit_sha = commit.get('commit', {}).get('sha', 'unknown')[:8]
                        commit_info = commit.get('commit', {})
                        author_info = commit_info.get('author', {})
                        commit_date = author_info.get('date', commit.get('created_at', 'unknown'))
                        commit_author = author_info.get('name', commit.get('author', {}).get('name', 'unknown'))
                        commit_message = commit_info.get('message', commit.get('message', 'No message'))

                    # æ£€æŸ¥æ˜¯å¦ä¸ºå½“å‰ç‰ˆæœ¬
                    full_commit_sha = commit.get('sha') or commit.get('commit', {}).get('sha', 'unknown')
                    is_current = current_commit_hash and current_commit_hash.startswith(full_commit_sha[:8])

                    # è·³è¿‡å·²ç»åœ¨ç¨³å®šç‰ˆæœ¬ä¸­çš„æäº¤
                    if commit_sha in stable_commit_hashes:
                        print(f"è·³è¿‡ç¨³å®šç‰ˆæœ¬æäº¤: {commit_sha} (å·²åœ¨ç¨³å®šç‰ˆæœ¬åˆ—è¡¨ä¸­)")
                        continue

                    if is_current:
                        print(f"æ‰¾åˆ°å½“å‰å¼€å‘ç‰ˆæœ¬: dev-{commit_sha} (æäº¤: {commit_sha}) - å½“å‰: {current_commit_hash[:8]} vs è¿œç¨‹: {full_commit_sha[:8]}")

                    development_versions.append({
                        "id": commit_sha,
                        "version": f"dev-{commit_sha}",
                        "date": commit_date,
                        "isCurrent": is_current,
                        "commit": commit_sha,
                        "message": commit_message.strip().split('\n')[0][:50] if commit_message else 'No message',
                        "author": commit_author
                    })

                    # é™åˆ¶å¼€å‘ç‰ˆæœ¬æ•°é‡ä¸º20ä¸ª
                    if len(development_versions) >= 20:
                        break

                except Exception as e:
                    print(f"Error processing commit: {e}")

        print(f"Processed {len(development_versions)} development versions")

        # ğŸš¨ å¦‚æœæ²¡æœ‰å¼€å‘ç‰ˆæœ¬æ•°æ®ï¼ˆGitHub APIé™åˆ¶ï¼‰ï¼Œä½¿ç”¨æœ¬åœ°Gitä»“åº“çœŸå®æ•°æ®
        if len(development_versions) == 0:
            print("GitHub API rate limited, using local Git repository data...")
            try:
                # å¯¼å…¥æœ¬åœ°ç‰ˆæœ¬ç®¡ç†å™¨
                import sys
                import os
                backend_dir = os.path.dirname(__file__)
                core_dir = os.path.join(backend_dir, 'core')
                if core_dir not in sys.path:
                    sys.path.insert(0, core_dir)
                
                from version_manager import VersionManager
                
                # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„åˆå§‹åŒ–ç‰ˆæœ¬ç®¡ç†å™¨
                paths = get_portable_paths()
                comfyui_dir = paths["comfyui_path"]
                version_mgr = VersionManager(comfyui_dir)
                
                if version_mgr.is_git_repo():
                    print(f"ä½¿ç”¨æœ¬åœ°Gitä»“åº“è·å–ç‰ˆæœ¬æ•°æ®: {comfyui_dir}")
                    
                    # è·å–ç‰ˆæœ¬å†å²ï¼ˆæœ€å¤š30ä¸ªæäº¤ï¼‰
                    local_versions = version_mgr.get_version_history(limit=30)
                    current_version = version_mgr.get_current_version()
                    
                    for i, version in enumerate(local_versions):
                        development_versions.append({
                            'id': version.commit_hash,
                            'version': f'dev-{version.commit_hash}',
                            'date': version.date.strftime('%Y-%m-%dT%H:%M:%SZ'),
                            'isCurrent': version.is_current,
                            'commit': version.commit_hash,
                            'message': version.commit_message.split('\n')[0][:100],  # å–ç¬¬ä¸€è¡Œå¹¶é™åˆ¶é•¿åº¦
                            'author': version.author
                        })
                    
                    print(f"æˆåŠŸè·å– {len(local_versions)} ä¸ªæœ¬åœ°Gitç‰ˆæœ¬")
                else:
                    print("ComfyUIç›®å½•ä¸æ˜¯æœ‰æ•ˆçš„Gitä»“åº“ï¼Œæ— æ³•è·å–æœ¬åœ°ç‰ˆæœ¬æ•°æ®")
                    
            except Exception as e:
                print(f"ä»æœ¬åœ°Gitè·å–ç‰ˆæœ¬æ•°æ®å¤±è´¥: {e}")
                print("ä½¿ç”¨æœ€å°å¤‡ç”¨æ•°æ®...")
                
                # æœ€åçš„å¤‡ç”¨æ–¹æ¡ˆï¼šåªç”Ÿæˆ1ä¸ªå½“å‰ç‰ˆæœ¬æ ‡è®°
                try:
                    paths = get_portable_paths()
                    comfyui_dir = paths["comfyui_path"]
                    if os.path.exists(os.path.join(comfyui_dir, ".git")):
                        import git
                        repo = git.Repo(comfyui_dir)
                        current = repo.head.commit
                        development_versions.append({
                            'id': current.hexsha[:8],
                            'version': f'dev-{current.hexsha[:8]}',
                            'date': current.committed_datetime.strftime('%Y-%m-%dT%H:%M:%SZ'),
                            'isCurrent': True,
                            'commit': current.hexsha[:8],
                            'message': current.message.strip().split('\n')[0][:100],
                            'author': current.author.name
                        })
                        print("ä½¿ç”¨å½“å‰Gitæäº¤ä½œä¸ºå”¯ä¸€ç‰ˆæœ¬")
                except Exception as fallback_error:
                    print(f"æœ€åå¤‡ç”¨æ–¹æ¡ˆä¹Ÿå¤±è´¥: {fallback_error}")
            
            print(f"æœ€ç»ˆè·å–äº† {len(development_versions)} ä¸ªå¼€å‘ç‰ˆæœ¬")

        # è·å–å½“å‰GitçŠ¶æ€
        current_branch = "unknown"
        current_commit = "unknown"

        try:
            # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
            paths = get_portable_paths()
            comfyui_dir = paths["comfyui_path"]

            if os.path.exists(os.path.join(comfyui_dir, ".git")):
                import git
                repo = git.Repo(comfyui_dir)

                # è·å–å½“å‰æäº¤
                current_commit = repo.head.commit.hexsha[:8]
                print(f"Current commit detected: {current_commit}")

                # è·å–å½“å‰åˆ†æ”¯ï¼ˆå¦‚æœå¯èƒ½ï¼‰
                try:
                    current_branch = repo.active_branch.name
                    print(f"Current branch detected: {current_branch}")
                except:
                    current_branch = "detached"
                    print("Repository is in detached HEAD state")

        except Exception as e:
            print(f"Failed to get current Git status: {e}")

        result = {
            "status": "success",
            "current_branch": current_branch,
            "current_commit": current_commit,
            "stable": stable_versions,
            "development": development_versions
        }

        # è°ƒè¯•è¾“å‡ºæœ€ç»ˆç»“æœ
        print(f"=== æœ€ç»ˆç‰ˆæœ¬æ•°æ®ç»“æ„ ===")
        print(f"å½“å‰åˆ†æ”¯: {current_branch}")
        print(f"å½“å‰æäº¤: {current_commit}")
        print(f"ç¨³å®šç‰ˆæœ¬æ•°é‡: {len(stable_versions)}")
        print(f"å¼€å‘ç‰ˆæœ¬æ•°é‡: {len(development_versions)}")

        if stable_versions:
            print("å‰3ä¸ªç¨³å®šç‰ˆæœ¬:")
            for i, version in enumerate(stable_versions[:3]):
                print(f"  {i+1}. {version.get('id', 'N/A')} - {version.get('version', 'N/A')} - Current: {version.get('isCurrent', False)}")

        if development_versions:
            print("å‰3ä¸ªå¼€å‘ç‰ˆæœ¬:")
            for i, version in enumerate(development_versions[:3]):
                print(f"  {i+1}. {version.get('id', 'N/A')} - {version.get('version', 'N/A')} - Current: {version.get('isCurrent', False)}")
        
        # ç¼“å­˜ç»“æœ
        from datetime import timedelta
        version_cache = result
        version_cache_expiry = now + timedelta(seconds=version_cache_duration)
        print(f"Version data cached until {version_cache_expiry}")
        
        return result

    except Exception as e:
        return {"status": "error", "message": f"è·å–ComfyUIç‰ˆæœ¬å¤±è´¥: {str(e)}"}

@app.post("/comfyui/switch-version")
async def switch_comfyui_version(request: dict):
    """åˆ‡æ¢ComfyUIç‰ˆæœ¬"""
    try:
        import git
        from datetime import datetime

        version_id = request.get('version_id')
        if not version_id:
            return {"status": "error", "message": "ç‰ˆæœ¬IDä¸èƒ½ä¸ºç©º"}

        # è·å–ComfyUIç›®å½•
        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        comfyui_dir = paths["comfyui_path"]

        if not os.path.exists(os.path.join(comfyui_dir, ".git")):
            return {"status": "error", "message": "ComfyUIç›®å½•ä¸æ˜¯Gitä»“åº“"}

        # ä½¿ç”¨GitPythonåˆ‡æ¢ç‰ˆæœ¬
        repo = git.Repo(comfyui_dir)

        # è·å–åˆ‡æ¢å‰çš„ä¿¡æ¯
        old_commit = repo.head.commit.hexsha[:8]
        old_branch = repo.active_branch.name if not repo.head.is_detached else "detached"

        try:
            # å…ˆè·å–è¿œç¨‹æ›´æ–°ï¼Œç¡®ä¿æœ¬åœ°ä»“åº“æœ‰æœ€æ–°çš„æäº¤
            print(f"è·å–è¿œç¨‹æ›´æ–°ä»¥ç¡®ä¿æäº¤ {version_id} å¯ç”¨...")
            try:
                repo.remotes.origin.fetch()
                print("è¿œç¨‹æ›´æ–°è·å–æˆåŠŸ")
            except Exception as fetch_error:
                print(f"è·å–è¿œç¨‹æ›´æ–°å¤±è´¥ï¼Œä½†ç»§ç»­å°è¯•åˆ‡æ¢: {fetch_error}")
            
            # å°è¯•åˆ‡æ¢åˆ°æŒ‡å®šç‰ˆæœ¬
            repo.git.checkout(version_id)

            # è·å–åˆ‡æ¢åçš„ä¿¡æ¯
            new_commit = repo.head.commit.hexsha[:8]
            new_branch = repo.active_branch.name if not repo.head.is_detached else "detached"

            # ç‰ˆæœ¬åˆ‡æ¢æˆåŠŸåç«‹å³æ¸…é™¤ç‰ˆæœ¬ç¼“å­˜ï¼Œç¡®ä¿ä¸‹æ¬¡è·å–æ—¶æ˜¾ç¤ºæ­£ç¡®çš„å½“å‰ç‰ˆæœ¬
            global version_cache, version_cache_expiry
            version_cache = None
            version_cache_expiry = None
            print(f"ç‰ˆæœ¬åˆ‡æ¢æˆåŠŸï¼Œå·²æ¸…é™¤ç‰ˆæœ¬ç¼“å­˜: {old_commit} -> {new_commit}")

            return {
                "status": "success",
                "message": f"æˆåŠŸåˆ‡æ¢åˆ°ç‰ˆæœ¬ {version_id}",
                "old_version": {
                    "commit": old_commit,
                    "branch": old_branch
                },
                "new_version": {
                    "commit": new_commit,
                    "branch": new_branch,
                    "version_id": version_id
                }
            }

        except git.exc.GitCommandError as e:
            return {
                "status": "error",
                "message": f"åˆ‡æ¢ç‰ˆæœ¬å¤±è´¥: {str(e)}"
            }

    except Exception as e:
        return {"status": "error", "message": f"åˆ‡æ¢ComfyUIç‰ˆæœ¬å¤±è´¥: {str(e)}"}

@app.post("/comfyui/clear-version-cache")
async def clear_comfyui_version_cache():
    """æ¸…é™¤ComfyUIç‰ˆæœ¬ç¼“å­˜"""
    global version_cache, version_cache_expiry

    try:
        version_cache = None
        version_cache_expiry = None
        print("ComfyUI version cache manually cleared")

        return {
            "status": "success",
            "message": "ComfyUIç‰ˆæœ¬ç¼“å­˜å·²æ¸…é™¤"
        }
    except Exception as e:
        return {
            "status": "error",
            "message": f"æ¸…é™¤ComfyUIç‰ˆæœ¬ç¼“å­˜å¤±è´¥: {str(e)}"
        }

@app.post("/git/checkout")
async def git_checkout(request: dict):
    """åˆ‡æ¢åˆ†æ”¯æˆ–æäº¤"""
    try:
        import git
        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        comfyui_dir = paths["comfyui_path"]
        
        target = request.get("target")
        if not target:
            return {"status": "error", "message": "æœªæŒ‡å®šåˆ‡æ¢ç›®æ ‡"}
        
        repo = git.Repo(comfyui_dir)
        
        # æ£€æŸ¥æ˜¯å¦æœ‰æœªæäº¤çš„æ›´æ”¹
        if repo.is_dirty():
            return {
                "status": "error", 
                "message": "æœ‰æœªæäº¤çš„æ›´æ”¹ï¼Œè¯·å…ˆæäº¤æˆ–æ’¤é”€æ›´æ”¹"
            }
        
        # æ‰§è¡Œåˆ‡æ¢
        repo.git.checkout(target)
        
        return {
            "status": "success",
            "message": f"å·²åˆ‡æ¢åˆ°: {target}"
        }
        
    except Exception as e:
        return {
            "status": "error",
            "message": f"åˆ‡æ¢å¤±è´¥: {str(e)}"
        }

@app.post("/git/pull")
async def git_pull():
    """æ‹‰å–æœ€æ–°ä»£ç """
    try:
        import git
        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        comfyui_dir = paths["comfyui_path"]
        
        repo = git.Repo(comfyui_dir)
        
        # æ£€æŸ¥æ˜¯å¦æœ‰æœªæäº¤çš„æ›´æ”¹
        if repo.is_dirty():
            return {
                "status": "error", 
                "message": "æœ‰æœªæäº¤çš„æ›´æ”¹ï¼Œè¯·å…ˆæäº¤æˆ–æ’¤é”€æ›´æ”¹"
            }
        
        # æ‰§è¡Œæ‹‰å–
        origin = repo.remotes.origin
        pull_info = origin.pull()
        
        return {
            "status": "success",
            "message": "ä»£ç æ›´æ–°å®Œæˆ",
            "details": str(pull_info[0])
        }
        
    except Exception as e:
        return {
            "status": "error",
            "message": f"æ‹‰å–å¤±è´¥: {str(e)}"
        }

@app.get("/git/official-status")
async def git_official_status():
    """è·å–ä¸å®˜æ–¹ä»“åº“çš„åŒæ­¥çŠ¶æ€"""
    try:
        import git
        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        comfyui_dir = paths["comfyui_path"]
        
        repo = git.Repo(comfyui_dir)
        
        # æ£€æŸ¥è¿œç¨‹ä»“åº“é…ç½®
        remotes = {}
        for remote in repo.remotes:
            remotes[remote.name] = remote.url
        
        # æ£€æŸ¥æ˜¯å¦é…ç½®äº†å®˜æ–¹ä¸Šæ¸¸
        upstream_url = "https://github.com/comfyanonymous/ComfyUI.git"
        has_upstream = False
        upstream_name = None
        
        for name, url in remotes.items():
            if "comfyanonymous/ComfyUI" in url:
                has_upstream = True
                upstream_name = name
                break
        
        # å¦‚æœæ²¡æœ‰é…ç½®ä¸Šæ¸¸ï¼Œå°è¯•æ·»åŠ 
        if not has_upstream:
            try:
                upstream = repo.create_remote('upstream', upstream_url)
                upstream.fetch()
                has_upstream = True
                upstream_name = 'upstream'
            except:
                pass
        
        result = {
            "status": "success",
            "remotes": remotes,
            "has_upstream": has_upstream,
            "upstream_name": upstream_name,
            "upstream_url": upstream_url
        }
        
        # å¦‚æœæœ‰ä¸Šæ¸¸ï¼Œæ£€æŸ¥åŒæ­¥çŠ¶æ€
        if has_upstream:
            try:
                upstream = repo.remotes[upstream_name]
                upstream.fetch()
                
                current_branch = repo.active_branch.name
                
                # æ£€æµ‹ä¸»åˆ†æ”¯åç§°ï¼ˆmainæˆ–masterï¼‰
                main_branch_name = "master"  # é»˜è®¤
                for branch_name in ['main', 'master', 'Main', 'Master']:
                    remote_ref_name = f"{upstream_name}/{branch_name}"
                    if any(ref.name == remote_ref_name for ref in upstream.refs):
                        main_branch_name = branch_name
                        break
                
                upstream_branch = f"{upstream_name}/{main_branch_name}"
                
                # è®¡ç®—è½åå’Œé¢†å…ˆçš„æäº¤æ•°
                try:
                    behind_commits = list(repo.iter_commits(f'{current_branch}..{upstream_branch}'))
                    ahead_commits = list(repo.iter_commits(f'{upstream_branch}..{current_branch}'))
                    
                    result.update({
                        "behind_count": len(behind_commits),
                        "ahead_count": len(ahead_commits),
                        "is_synced": len(behind_commits) == 0,
                        "latest_upstream_commit": {
                            "hash": behind_commits[0].hexsha[:8] if behind_commits else repo.head.commit.hexsha[:8],
                            "message": behind_commits[0].message.strip() if behind_commits else "å·²æ˜¯æœ€æ–°",
                            "date": behind_commits[0].committed_datetime.strftime("%Y-%m-%d %H:%M:%S") if behind_commits else ""
                        }
                    })
                except:
                    result.update({
                        "behind_count": 0,
                        "ahead_count": 0,
                        "is_synced": True
                    })
            except:
                pass
        
        return result
        
    except Exception as e:
        return {
            "status": "error",
            "message": f"æ£€æŸ¥å®˜æ–¹åŒæ­¥çŠ¶æ€å¤±è´¥: {str(e)}"
        }

@app.post("/git/sync-upstream")
async def git_sync_upstream():
    """åŒæ­¥å®˜æ–¹ä¸Šæ¸¸ä»£ç """
    try:
        import git
        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        comfyui_dir = paths["comfyui_path"]
        
        repo = git.Repo(comfyui_dir)
        
        # æ£€æŸ¥æ˜¯å¦æœ‰æœªæäº¤çš„æ›´æ”¹
        if repo.is_dirty():
            return {
                "status": "error", 
                "message": "æœ‰æœªæäº¤çš„æ›´æ”¹ï¼Œè¯·å…ˆæäº¤æˆ–æ’¤é”€æ›´æ”¹"
            }
        
        # æŸ¥æ‰¾æŒ‡å‘å®˜æ–¹ä»“åº“çš„è¿œç¨‹
        upstream_url = "https://github.com/comfyanonymous/ComfyUI.git"
        upstream_name = None
        
        # æ£€æŸ¥ç°æœ‰çš„è¿œç¨‹é…ç½®
        for remote in repo.remotes:
            if "comfyanonymous/ComfyUI" in remote.url:
                upstream_name = remote.name
                break
        
        # å¦‚æœæ²¡æ‰¾åˆ°å®˜æ–¹è¿œç¨‹ï¼Œåˆ›å»ºä¸€ä¸ª
        if not upstream_name:
            upstream = repo.create_remote('upstream', upstream_url)
            upstream_name = 'upstream'
        else:
            upstream = repo.remotes[upstream_name]
        
        # è·å–ä¸Šæ¸¸æœ€æ–°ä»£ç 
        upstream.fetch()
        
        # åˆå¹¶ä¸Šæ¸¸ä¸»åˆ†æ”¯åˆ°å½“å‰åˆ†æ”¯
        current_branch = repo.active_branch.name
        
        # æ£€æµ‹ä¸»åˆ†æ”¯åç§°ï¼ˆmainæˆ–masterï¼‰
        main_branch_name = "master"  # é»˜è®¤
        upstream = repo.remotes[upstream_name]
        for branch_name in ['main', 'master', 'Main', 'Master']:
            remote_ref_name = f"{upstream_name}/{branch_name}"
            if any(ref.name == remote_ref_name for ref in upstream.refs):
                main_branch_name = branch_name
                break
        
        upstream_branch = f"{upstream_name}/{main_branch_name}"
        
        # æ‰§è¡Œåˆå¹¶
        repo.git.merge(upstream_branch)
        
        return {
            "status": "success",
            "message": "å·²åŒæ­¥å®˜æ–¹æœ€æ–°ä»£ç ",
            "branch": current_branch
        }
        
    except Exception as e:
        return {
            "status": "error",
            "message": f"åŒæ­¥å¤±è´¥: {str(e)}"
        }

# é¡¹ç›®ç›®å½•ç®¡ç†API
@app.get("/project/directories")
async def get_project_directories():
    """è·å–é¡¹ç›®ç›®å½•ä¿¡æ¯"""
    try:
        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        comfyui_dir = paths["comfyui_path"]
        
        directories = {
            "input": os.path.join(comfyui_dir, "input"),
            "output": os.path.join(comfyui_dir, "output"),
            "models": os.path.join(comfyui_dir, "models"),
            "custom_nodes": os.path.join(comfyui_dir, "custom_nodes"),
            "user": os.path.join(comfyui_dir, "user"),
            "temp": os.path.join(comfyui_dir, "temp")
        }
        
        # æ£€æŸ¥ç›®å½•çŠ¶æ€
        directory_info = {}
        for name, path in directories.items():
            exists = os.path.exists(path)
            size = 0
            file_count = 0
            
            if exists:
                try:
                    # è®¡ç®—ç›®å½•å¤§å°å’Œæ–‡ä»¶æ•°é‡
                    total_size = 0
                    total_files = 0
                    
                    for dirpath, dirnames, filenames in os.walk(path):
                        total_files += len(filenames)
                        for filename in filenames:
                            filepath = os.path.join(dirpath, filename)
                            try:
                                total_size += os.path.getsize(filepath)
                            except:
                                continue
                    
                    size = total_size
                    file_count = total_files
                except:
                    pass
            
            directory_info[name] = {
                "path": path,
                "exists": exists,
                "size": size,
                "file_count": file_count,
                "size_mb": round(size / (1024 * 1024), 2) if size > 0 else 0
            }
        
        return {
            "status": "success",
            "directories": directory_info,
            "comfyui_root": comfyui_dir
        }
        
    except Exception as e:
        return {
            "status": "error",
            "message": f"è·å–ç›®å½•ä¿¡æ¯å¤±è´¥: {str(e)}"
        }

@app.get("/project/directory/{dir_name}")
async def get_directory_contents(dir_name: str):
    """è·å–æŒ‡å®šç›®å½•çš„å†…å®¹"""
    try:
        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        comfyui_dir = paths["comfyui_path"]
        
        valid_dirs = ["input", "output", "models", "custom_nodes", "user", "temp"]
        if dir_name not in valid_dirs:
            return {"status": "error", "message": "æ— æ•ˆçš„ç›®å½•å"}
        
        dir_path = os.path.join(comfyui_dir, dir_name)
        
        if not os.path.exists(dir_path):
            return {"status": "error", "message": "ç›®å½•ä¸å­˜åœ¨"}
        
        contents = []
        try:
            for item in os.listdir(dir_path):
                item_path = os.path.join(dir_path, item)
                is_dir = os.path.isdir(item_path)
                size = 0
                
                if not is_dir:
                    try:
                        size = os.path.getsize(item_path)
                    except:
                        pass
                
                contents.append({
                    "name": item,
                    "type": "directory" if is_dir else "file",
                    "size": size,
                    "size_mb": round(size / (1024 * 1024), 2) if size > 0 else 0
                })
        except Exception as e:
            return {"status": "error", "message": f"è¯»å–ç›®å½•å¤±è´¥: {str(e)}"}
        
        return {
            "status": "success",
            "directory": dir_name,
            "path": dir_path,
            "contents": contents
        }
        
    except Exception as e:
        return {
            "status": "error",
            "message": f"è·å–ç›®å½•å†…å®¹å¤±è´¥: {str(e)}"
        }

@app.post("/project/create-directory")
async def create_project_directory(request: dict):
    """åˆ›å»ºé¡¹ç›®ç›®å½•"""
    try:
        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        comfyui_dir = paths["comfyui_path"]
        
        dir_name = request.get("name")
        if not dir_name:
            return {"status": "error", "message": "æœªæŒ‡å®šç›®å½•å"}
        
        # å®‰å…¨æ£€æŸ¥ï¼šåªå…è®¸åœ¨é¢„å®šä¹‰çš„ç›®å½•ä¸‹åˆ›å»ºå­ç›®å½•
        parent_dir = request.get("parent", "")
        valid_parents = ["input", "output", "models", "custom_nodes", "user", "temp"]
        
        if parent_dir and parent_dir in valid_parents:
            target_path = os.path.join(comfyui_dir, parent_dir, dir_name)
        else:
            return {"status": "error", "message": "æ— æ•ˆçš„çˆ¶ç›®å½•"}
        
        # æ£€æŸ¥ç›®å½•æ˜¯å¦å·²å­˜åœ¨
        if os.path.exists(target_path):
            return {"status": "error", "message": "ç›®å½•å·²å­˜åœ¨"}
        
        # åˆ›å»ºç›®å½•
        os.makedirs(target_path, exist_ok=True)
        
        return {
            "status": "success",
            "message": f"ç›®å½•åˆ›å»ºæˆåŠŸ: {target_path}",
            "path": target_path
        }
        
    except Exception as e:
        return {
            "status": "error",
            "message": f"åˆ›å»ºç›®å½•å¤±è´¥: {str(e)}"
        }

@app.post("/project/open-directory")
async def open_project_directory(request: dict):
    """åœ¨æ–‡ä»¶ç®¡ç†å™¨ä¸­æ‰“å¼€é¡¹ç›®ç›®å½•"""
    try:
        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        comfyui_dir = paths["comfyui_path"]
        
        dir_name = request.get("directory")
        if not dir_name:
            return {"status": "error", "message": "æœªæŒ‡å®šç›®å½•å"}
        
        # å®‰å…¨æ£€æŸ¥ï¼šåªå…è®¸æ‰“å¼€é¢„å®šä¹‰çš„ç›®å½•
        valid_dirs = ["input", "output", "models", "custom_nodes", "user", "temp", "root"]
        if dir_name not in valid_dirs:
            return {"status": "error", "message": "æ— æ•ˆçš„ç›®å½•å"}
        
        # æ„å»ºç›®å½•è·¯å¾„
        if dir_name == "root":
            target_path = comfyui_dir
        else:
            target_path = os.path.join(comfyui_dir, dir_name)
        
        # æ£€æŸ¥ç›®å½•æ˜¯å¦å­˜åœ¨
        if not os.path.exists(target_path):
            return {"status": "error", "message": f"ç›®å½•ä¸å­˜åœ¨: {target_path}"}
        
        # æ ¹æ®æ“ä½œç³»ç»Ÿæ‰“å¼€ç›®å½•
        import subprocess
        import sys
        
        try:
            if sys.platform == "win32":
                # Windows
                subprocess.run(["explorer", target_path], check=True)
            elif sys.platform == "darwin":
                # macOS
                subprocess.run(["open", target_path], check=True)
            else:
                # Linux
                subprocess.run(["xdg-open", target_path], check=True)
            
            return {
                "status": "success",
                "message": f"å·²åœ¨æ–‡ä»¶ç®¡ç†å™¨ä¸­æ‰“å¼€: {dir_name}",
                "path": target_path
            }
            
        except subprocess.CalledProcessError as e:
            return {
                "status": "error",
                "message": f"æ‰“å¼€ç›®å½•å¤±è´¥: {str(e)}"
            }
        except FileNotFoundError:
            return {
                "status": "error",
                "message": "æ‰¾ä¸åˆ°æ–‡ä»¶ç®¡ç†å™¨ç¨‹åº"
            }
        
    except Exception as e:
        return {
            "status": "error",
            "message": f"æ‰“å¼€ç›®å½•å¤±è´¥: {str(e)}"
        }

# æ’ä»¶ç¼“å­˜
_plugin_cache = None
_plugin_cache_time = 0
_plugin_cache_duration = 300  # 5åˆ†é’Ÿç¼“å­˜ï¼ˆä¼˜åŒ–åï¼‰

# è‡ªå®šä¹‰èŠ‚ç‚¹ç®¡ç†API
@app.get("/nodes/installed")
async def get_installed_nodes(force_refresh: bool = False, skip_update: bool = False):
    """è·å–å·²å®‰è£…çš„è‡ªå®šä¹‰èŠ‚ç‚¹ï¼ˆä¾¿æºåŒ…æ€§èƒ½ä¼˜åŒ–ç‰ˆæœ¬ï¼‰"""
    global _plugin_cache, _plugin_cache_time

    try:
        start_time = time.time()

        # æ£€æŸ¥æ˜¯å¦å¼ºåˆ¶åˆ·æ–°
        if force_refresh:
            print("Force refresh requested, clearing plugin cache")
            _plugin_cache = None
            _plugin_cache_time = 0

        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        custom_nodes_dir = os.path.join(paths["comfyui_path"], "custom_nodes")

        if not os.path.exists(custom_nodes_dir):
            result = {
                "status": "success",
                "nodes": [],
                "message": "custom_nodesç›®å½•ä¸å­˜åœ¨"
            }
            _plugin_cache = result
            _plugin_cache_time = time.time()
            return result

        # å°è¯•ä½¿ç”¨ä¾¿æºåŒ…æ€§èƒ½ä¼˜åŒ–å™¨
        try:
            from .portable_performance_optimizer import get_portable_optimizer

            optimizer = get_portable_optimizer(custom_nodes_dir)

            # å¦‚æœä¸æ˜¯å¼ºåˆ¶åˆ·æ–°ï¼Œå…ˆå°è¯•ä»ç¼“å­˜è·å–
            if not force_refresh:
                cached_plugins = await optimizer.get_cached_plugins()
                if cached_plugins:
                    print("ä½¿ç”¨ä¾¿æºåŒ…ä¼˜åŒ–å™¨ç¼“å­˜æ•°æ®")
                    result = {
                        "status": "success",
                        "nodes": cached_plugins,
                        "total": len(cached_plugins),
                        "custom_nodes_path": custom_nodes_dir,
                        "scan_time": "0.00s (cached)",
                        "portable_optimized": True
                    }
                    _plugin_cache = result
                    _plugin_cache_time = time.time()
                    return result

            # ä½¿ç”¨ä¼˜åŒ–å™¨æ‰«ææ’ä»¶
            print("ä½¿ç”¨ä¾¿æºåŒ…ä¼˜åŒ–å™¨æ‰«ææ’ä»¶")
            nodes = await optimizer.scan_plugins_fast()

            # ç¼“å­˜ç»“æœ
            await optimizer.cache_plugins(nodes)

            scan_time = time.time() - start_time
            result = {
                "status": "success",
                "nodes": nodes,
                "total": len(nodes),
                "custom_nodes_path": custom_nodes_dir,
                "scan_time": f"{scan_time:.2f}s",
                "portable_optimized": True
            }

            # æ›´æ–°å†…å­˜ç¼“å­˜
            _plugin_cache = result
            _plugin_cache_time = time.time()

            print(f"ä¾¿æºåŒ…ä¼˜åŒ–æ‰«æå®Œæˆ: {scan_time:.2f}s, æ‰¾åˆ° {len(nodes)} ä¸ªæ’ä»¶")
            return result

        except ImportError as e:
            print(f"è­¦å‘Š ä¾¿æºåŒ…ä¼˜åŒ–å™¨ä¸å¯ç”¨: {e}")
            print("å›é€€åˆ°æ ‡å‡†æ‰«ææ¨¡å¼")
        except Exception as e:
            print(f"è­¦å‘Š ä¾¿æºåŒ…ä¼˜åŒ–å™¨é”™è¯¯: {e}")
            print("å›é€€åˆ°æ ‡å‡†æ‰«ææ¨¡å¼")

        # å›é€€åˆ°æ ‡å‡†æ‰«æï¼ˆæ£€æŸ¥å†…å­˜ç¼“å­˜ï¼‰
        current_time = time.time()
        if _plugin_cache and (current_time - _plugin_cache_time) < _plugin_cache_duration:
            print(f"ä½¿ç”¨å†…å­˜ç¼“å­˜æ•°æ® (age: {current_time - _plugin_cache_time:.1f}s)")
            return _plugin_cache

        print(f"æ ‡å‡†æ¨¡å¼æ‰«ææ’ä»¶: {custom_nodes_dir}")
        nodes = []
        
        # å¿«é€Ÿæ‰«æcustom_nodesç›®å½•ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼‰
        for item_name in os.listdir(custom_nodes_dir):
            item_path = os.path.join(custom_nodes_dir, item_name)

            # è·³è¿‡æ–‡ä»¶ï¼Œåªå¤„ç†ç›®å½•
            if not os.path.isdir(item_path):
                continue

            # è·³è¿‡ç‰¹æ®Šç›®å½•
            if item_name.startswith('.') or item_name == '__pycache__':
                continue

            # åˆ¤æ–­èŠ‚ç‚¹çŠ¶æ€
            is_disabled = item_name.endswith('.disabled')
            actual_name = item_name.replace('.disabled', '') if is_disabled else item_name
            status = 'disabled' if is_disabled else 'enabled'

            # å¿«é€Ÿæ£€æŸ¥æ˜¯å¦åŒ…å«Pythonæ–‡ä»¶ï¼ˆä¸æ·±åº¦éå†ï¼‰
            has_python_files = False
            try:
                for file in os.listdir(item_path):
                    if file.endswith('.py'):
                        has_python_files = True
                        break
            except:
                continue

            # å¦‚æœæ²¡æœ‰Pythonæ–‡ä»¶ï¼Œè·³è¿‡
            if not has_python_files:
                continue

            # åŸºç¡€èŠ‚ç‚¹ä¿¡æ¯ï¼ˆæœ€å°åŒ–æ–‡ä»¶æ“ä½œï¼‰
            node_info = {
                "name": actual_name,
                "path": item_path,
                "status": status,
                "enabled": status == 'enabled',  # æ·»åŠ enabledå­—æ®µ
                "fileCount": 0,  # æš‚æ—¶è®¾ä¸º0ï¼Œé¿å…è€—æ—¶çš„æ–‡ä»¶ç»Ÿè®¡
                "author": "æœªçŸ¥",
                "version": "æœªçŸ¥",
                "description": f"è‡ªå®šä¹‰èŠ‚ç‚¹: {actual_name}",
                "hasUpdate": False,
                "repo_url": f"https://github.com/search?q={actual_name}",
                "date": "æœªçŸ¥",
                "git_date": "æœªçŸ¥"
            }
            
            # å¿«é€Ÿè·å–åŸºæœ¬ä¿¡æ¯ï¼ˆä¿æŒæ€§èƒ½ä¼˜åŒ–ï¼‰
            try:
                # æ£€æŸ¥æ˜¯å¦æ˜¯Gitä»“åº“å¹¶è·å–ç‰ˆæœ¬ä¿¡æ¯
                if os.path.exists(os.path.join(item_path, ".git")):
                    try:
                        import subprocess

                        # è·å–Gitè¿œç¨‹URL
                        result = subprocess.run(
                            ["git", "remote", "get-url", "origin"],
                            capture_output=True,
                            text=True,
                            cwd=item_path,
                            timeout=2  # 2ç§’è¶…æ—¶
                        )
                        if result.returncode == 0:
                            origin_url = result.stdout.strip()
                            node_info["repo_url"] = origin_url
                            # ä»URLä¸­æå–ä½œè€…ä¿¡æ¯
                            if "github.com" in origin_url:
                                parts = origin_url.replace(".git", "").split("/")
                                if len(parts) >= 2:
                                    node_info["author"] = parts[-2]

                        # è·å–å½“å‰åˆ†æ”¯å’Œæœ€æ–°æäº¤ä¿¡æ¯
                        branch_result = subprocess.run(
                            ["git", "rev-parse", "--abbrev-ref", "HEAD"],
                            capture_output=True,
                            text=True,
                            cwd=item_path,
                            timeout=2
                        )
                        commit_result = subprocess.run(
                            ["git", "rev-parse", "--short", "HEAD"],
                            capture_output=True,
                            text=True,
                            cwd=item_path,
                            timeout=2
                        )
                        date_result = subprocess.run(
                            ["git", "log", "-1", "--format=%cd", "--date=short"],
                            capture_output=True,
                            text=True,
                            cwd=item_path,
                            timeout=2
                        )

                        if branch_result.returncode == 0 and commit_result.returncode == 0:
                            branch = branch_result.stdout.strip()
                            commit = commit_result.stdout.strip()
                            node_info["version"] = f"{branch} ({commit})"
                            node_info["git_branch"] = branch
                            node_info["git_commit"] = commit

                            if date_result.returncode == 0:
                                commit_date = date_result.stdout.strip()
                                node_info["date"] = commit_date
                                node_info["git_date"] = commit_date

                            # æ£€æŸ¥æ˜¯å¦ä¸ºæœ€æ–°ç‰ˆæœ¬ï¼ˆæ”¹è¿›çš„æ£€æŸ¥æ–¹æ³•ï¼‰
                            try:
                                # è·å–å½“å‰åˆ†æ”¯çš„æœ¬åœ°æäº¤
                                local_commit = subprocess.run(
                                    ["git", "rev-parse", "HEAD"],
                                    capture_output=True,
                                    text=True,
                                    cwd=item_path,
                                    timeout=2
                                ).stdout.strip()

                                # å°è¯•è·å–è¿œç¨‹åˆ†æ”¯çš„æœ€æ–°æäº¤
                                remote_commit = None

                                # æ–¹æ³•1ï¼šå°è¯•è·å–å½“å‰åˆ†æ”¯å¯¹åº”çš„è¿œç¨‹åˆ†æ”¯
                                try:
                                    remote_branch_result = subprocess.run(
                                        ["git", "rev-parse", f"origin/{branch}"],
                                        capture_output=True,
                                        text=True,
                                        cwd=item_path,
                                        timeout=2
                                    )
                                    if remote_branch_result.returncode == 0:
                                        remote_commit = remote_branch_result.stdout.strip()
                                except:
                                    pass

                                # æ–¹æ³•2ï¼šå¦‚æœæ–¹æ³•1å¤±è´¥ï¼Œå°è¯•è·å–origin/mainæˆ–origin/master
                                if not remote_commit:
                                    for default_branch in ['main', 'master']:
                                        try:
                                            default_result = subprocess.run(
                                                ["git", "rev-parse", f"origin/{default_branch}"],
                                                capture_output=True,
                                                text=True,
                                                cwd=item_path,
                                                timeout=2
                                            )
                                            if default_result.returncode == 0:
                                                remote_commit = default_result.stdout.strip()
                                                break
                                        except:
                                            continue

                                # æ¯”è¾ƒæœ¬åœ°å’Œè¿œç¨‹æäº¤
                                if remote_commit:
                                    node_info["isLatestVersion"] = (local_commit == remote_commit)
                                    print(f"Version check for {actual_name}: local={local_commit[:8]}, remote={remote_commit[:8]}, isLatest={node_info['isLatestVersion']}")
                                else:
                                    node_info["isLatestVersion"] = True  # æ— æ³•è·å–è¿œç¨‹ä¿¡æ¯ï¼Œé»˜è®¤è®¤ä¸ºæ˜¯æœ€æ–°ç‰ˆæœ¬
                                    print(f"Version check for {actual_name}: unable to get remote commit, assuming latest")

                            except Exception as e:
                                node_info["isLatestVersion"] = True  # é»˜è®¤è®¤ä¸ºæ˜¯æœ€æ–°ç‰ˆæœ¬
                                print(f"Version check failed for {actual_name}: {e}")

                    except Exception as e:
                        print(f"Git info extraction failed for {actual_name}: {e}")
                        pass

                # å¦‚æœæ²¡æœ‰Gitä¿¡æ¯ï¼Œä½¿ç”¨æ–‡ä»¶ä¿®æ”¹æ—¶é—´ä½œä¸ºå¤‡ç”¨
                if node_info["date"] == "æœªçŸ¥":
                    try:
                        # è·å–ç›®å½•ä¸­æœ€æ–°çš„Pythonæ–‡ä»¶ä¿®æ”¹æ—¶é—´
                        latest_time = 0
                        for root, dirs, files in os.walk(item_path):
                            for file in files:
                                if file.endswith('.py'):
                                    file_path = os.path.join(root, file)
                                    try:
                                        mtime = os.path.getmtime(file_path)
                                        if mtime > latest_time:
                                            latest_time = mtime
                                    except:
                                        continue

                        if latest_time > 0:
                            import datetime
                            date_str = datetime.datetime.fromtimestamp(latest_time).strftime('%Y-%m-%d')
                            node_info["date"] = date_str
                            node_info["git_date"] = date_str
                            if node_info["version"] == "æœªçŸ¥":
                                node_info["version"] = f"æœ¬åœ°ç‰ˆæœ¬ ({date_str})"
                    except Exception as e:
                        print(f"File time extraction failed for {actual_name}: {e}")
                        pass

                # å¿«é€Ÿæ£€æŸ¥pyproject.tomlè·å–ç‰ˆæœ¬ä¿¡æ¯
                pyproject_file = os.path.join(item_path, "pyproject.toml")
                if os.path.exists(pyproject_file):
                    try:
                        with open(pyproject_file, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read(1000)  # åªè¯»å‰1000å­—ç¬¦
                            # ç®€å•è§£æç‰ˆæœ¬ä¿¡æ¯
                            for line in content.split('\n'):
                                if 'version = ' in line and node_info["version"] == "æœªçŸ¥":
                                    version = line.split('version = ')[1].strip().strip('"\'')
                                    node_info["version"] = version
                                elif 'PublisherId = ' in line and node_info["author"] == "æœªçŸ¥":
                                    author = line.split('PublisherId = ')[1].strip().strip('"\'')
                                    node_info["author"] = author
                    except:
                        pass

                # å¿«é€Ÿæ£€æŸ¥READMEæ–‡ä»¶è·å–æè¿°
                for readme_name in ["README.md", "readme.md", "README.txt", "readme.txt"]:
                    readme_path = os.path.join(item_path, readme_name)
                    if os.path.exists(readme_path):
                        try:
                            with open(readme_path, 'r', encoding='utf-8', errors='ignore') as f:
                                content = f.read(500)  # åªè¯»å‰500å­—ç¬¦
                                lines = content.split('\n')
                                if len(lines) > 0:
                                    # å–ç¬¬ä¸€è¡Œä½œä¸ºæè¿°ï¼ˆé€šå¸¸æ˜¯æ ‡é¢˜ï¼‰
                                    first_line = lines[0].strip().replace('#', '').strip()
                                    if first_line and len(first_line) > 5:
                                        node_info["description"] = first_line[:200]
                                        break
                        except:
                            pass
            except Exception as e:
                print(f"Error processing plugin {actual_name}: {e}")
                pass

            # æ·»åŠ èŠ‚ç‚¹åˆ°åˆ—è¡¨
            nodes.append(node_info)

        # æŒ‰åç§°æ’åº
        nodes.sort(key=lambda x: x["name"].lower())

        # è®¡ç®—æ‰«ææ—¶é—´
        scan_time = time.time() - start_time
        print(f"Plugin scan completed in {scan_time:.2f}s, found {len(nodes)} plugins")

        # ç¼“å­˜ç»“æœ
        result = {
            "status": "success",
            "nodes": nodes,
            "total": len(nodes),
            "custom_nodes_path": custom_nodes_dir,
            "scan_time": f"{scan_time:.2f}s"
        }
        _plugin_cache = result
        _plugin_cache_time = current_time

        return result

    except Exception as e:
        print(f"Error in get_installed_nodes: {e}")
        return {
            "status": "error",
            "message": f"è·å–å·²å®‰è£…èŠ‚ç‚¹å¤±è´¥: {str(e)}"
        }





@app.get("/nodes/check-updates")
async def check_nodes_updates():
    """æ£€æŸ¥èŠ‚ç‚¹æ›´æ–°"""
    try:
        # è¿™æ˜¯ä¸€ä¸ªå ä½ç¬¦å®ç°
        # å®é™…å®ç°éœ€è¦æ£€æŸ¥æ¯ä¸ªæœ‰Gitä»“åº“çš„èŠ‚ç‚¹çš„è¿œç¨‹æ›´æ–°
        return {
            "status": "success",
            "updates": [],
            "message": "æ›´æ–°æ£€æŸ¥åŠŸèƒ½å¼€å‘ä¸­"
        }
    except Exception as e:
        return {
            "status": "error",
            "message": f"æ£€æŸ¥æ›´æ–°å¤±è´¥: {str(e)}"
        }

@app.post("/nodes/update")
async def update_node(request: dict):
    """æ›´æ–°å•ä¸ªèŠ‚ç‚¹"""
    try:
        node_name = request.get("name")
        if not node_name:
            return {"status": "error", "message": "æœªæŒ‡å®šèŠ‚ç‚¹åç§°"}
        
        # å ä½ç¬¦å®ç°
        return {
            "status": "success",
            "message": f"èŠ‚ç‚¹ {node_name} æ›´æ–°åŠŸèƒ½å¼€å‘ä¸­"
        }
    except Exception as e:
        return {
            "status": "error",
            "message": f"æ›´æ–°èŠ‚ç‚¹å¤±è´¥: {str(e)}"
        }


# å¯åŠ¨å™¨è‡ªæˆ‘ä¿æŠ¤å’Œè¯Šæ–­API
@app.get("/launcher/health")
async def launcher_health_check():
    """æ£€æŸ¥å¯åŠ¨å™¨å®Œæ•´æ€§å’Œå¥åº·çŠ¶æ€"""
    try:
        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        comfyui_dir = paths["comfyui_path"]
        
        # æ£€æŸ¥å…³é”®æ–‡ä»¶
        critical_files = {
            "backend_main": os.path.join(launcher_dir, "backend", "start_fixed_cors.py"),
            "frontend_advanced": os.path.join(launcher_dir, "advanced_launcher.html"),
            "frontend_simple": os.path.join(launcher_dir, "web_frontend.html"),
            "requirements": os.path.join(launcher_dir, "backend", "requirements.txt")
        }
        
        file_status = {}
        missing_files = []
        
        for name, path in critical_files.items():
            exists = os.path.exists(path)
            file_status[name] = {
                "path": path,
                "exists": exists,
                "size": os.path.getsize(path) if exists else 0
            }
            if not exists:
                missing_files.append(name)
        
        # æ£€æŸ¥GitçŠ¶æ€
        git_status = "unknown"
        try:
            import git
            repo = git.Repo(comfyui_dir)
            
            # æ£€æŸ¥æ˜¯å¦æœ‰æœªæäº¤çš„å¯åŠ¨å™¨æ›´æ”¹
            changed_files = [item.a_path for item in repo.index.diff(None)]
            launcher_changes = [f for f in changed_files if "ComfyUI-Launcher" in f]
            
            if launcher_changes:
                git_status = "has_launcher_changes"
            else:
                git_status = "clean"
                
        except Exception as e:
            git_status = f"git_error: {str(e)}"
        
        # æ£€æŸ¥Pythonç¯å¢ƒ
        python_status = {
            "version": sys.version,
            "executable": sys.executable,
            "packages": {}
        }
        
        # æ£€æŸ¥å…³é”®ä¾èµ–åŒ…
        required_packages = ["fastapi", "uvicorn", "psutil", "gitpython"]
        for package in required_packages:
            try:
                __import__(package)
                python_status["packages"][package] = "available"
            except ImportError:
                python_status["packages"][package] = "missing"
        
        # æ•´ä½“å¥åº·çŠ¶æ€è¯„ä¼°
        health_score = 100
        issues = []
        
        if missing_files:
            health_score -= len(missing_files) * 20
            issues.append(f"ç¼ºå°‘å…³é”®æ–‡ä»¶: {', '.join(missing_files)}")
        
        missing_packages = [pkg for pkg, status in python_status["packages"].items() if status == "missing"]
        if missing_packages:
            health_score -= len(missing_packages) * 10
            issues.append(f"ç¼ºå°‘PythonåŒ…: {', '.join(missing_packages)}")
        
        if "error" in git_status:
            health_score -= 15
            issues.append("GitçŠ¶æ€æ£€æŸ¥å¤±è´¥")
        
        # ç¡®å®šå¥åº·ç­‰çº§
        if health_score >= 90:
            health_level = "excellent"
        elif health_score >= 70:
            health_level = "good"
        elif health_score >= 50:
            health_level = "warning"
        else:
            health_level = "critical"
        
        return {
            "status": "success",
            "health_score": health_score,
            "health_level": health_level,
            "launcher_directory": launcher_dir,
            "file_status": file_status,
            "missing_files": missing_files,
            "git_status": git_status,
            "python_status": python_status,
            "issues": issues,
            "recommendations": get_health_recommendations(health_level, issues)
        }
        
    except Exception as e:
        return {
            "status": "error",
            "message": f"å¥åº·æ£€æŸ¥å¤±è´¥: {str(e)}"
        }

def get_health_recommendations(health_level, issues):
    """æ ¹æ®å¥åº·çŠ¶æ€æä¾›å»ºè®®"""
    recommendations = []
    
    if health_level == "critical":
        recommendations.append("è­¦å‘Š å¯åŠ¨å™¨çŠ¶æ€ä¸¥é‡å¼‚å¸¸ï¼Œå»ºè®®é‡æ–°å®‰è£…")
        recommendations.append(" å»ºè®®å¤‡ä»½å½“å‰é…ç½®åé‡æ–°éƒ¨ç½²å¯åŠ¨å™¨")
    elif health_level == "warning":
        recommendations.append("è­¦å‘Š å‘ç°ä¸€äº›é—®é¢˜ï¼Œå»ºè®®å°½å¿«ä¿®å¤")
    
    for issue in issues:
        if "ç¼ºå°‘å…³é”®æ–‡ä»¶" in issue:
            recommendations.append(" é‡æ–°ä¸‹è½½å¯åŠ¨å™¨æ–‡ä»¶æˆ–ä»å¤‡ä»½æ¢å¤")
        elif "ç¼ºå°‘PythonåŒ…" in issue:
            recommendations.append(" è¿è¡Œ: pip install -r requirements.txt")
        elif "GitçŠ¶æ€æ£€æŸ¥å¤±è´¥" in issue:
            recommendations.append(" æ£€æŸ¥Gitä»“åº“å®Œæ•´æ€§")
    
    if not recommendations:
        recommendations.append("OK å¯åŠ¨å™¨è¿è¡Œè‰¯å¥½ï¼Œæ— éœ€ç‰¹æ®Šæ“ä½œ")
    
    return recommendations

@app.post("/launcher/backup")
async def create_launcher_backup():
    """åˆ›å»ºå¯åŠ¨å™¨å¤‡ä»½"""
    try:
        import shutil
        import datetime
        
        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        comfyui_dir = paths["comfyui_path"]
        
        # åˆ›å»ºå¤‡ä»½ç›®å½•
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_name = f"ComfyUI-Launcher-Backup-{timestamp}"
        backup_path = os.path.join(comfyui_dir, backup_name)
        
        # æ’é™¤ä¸éœ€è¦å¤‡ä»½çš„ç›®å½•
        def ignore_patterns(dir, files):
            return ['__pycache__', '*.pyc', '.git', 'node_modules']
        
        shutil.copytree(launcher_dir, backup_path, ignore=ignore_patterns)
        
        # è®¡ç®—å¤‡ä»½å¤§å°
        total_size = 0
        for dirpath, dirnames, filenames in os.walk(backup_path):
            for f in filenames:
                fp = os.path.join(dirpath, f)
                total_size += os.path.getsize(fp)
        
        return {
            "status": "success",
            "message": "å¯åŠ¨å™¨å¤‡ä»½åˆ›å»ºæˆåŠŸ",
            "backup_path": backup_path,
            "backup_size": round(total_size / (1024 * 1024), 2),  # MB
            "timestamp": timestamp
        }
        
    except Exception as e:
        return {
            "status": "error",
            "message": f"å¤‡ä»½åˆ›å»ºå¤±è´¥: {str(e)}"
        }

@app.get("/launcher/version-safety")
async def check_version_safety():
    """æ£€æŸ¥ç‰ˆæœ¬åˆ‡æ¢å®‰å…¨æ€§"""
    try:
        import git
        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        comfyui_dir = paths["comfyui_path"]
        
        repo = git.Repo(comfyui_dir)
        
        # æ£€æŸ¥å½“å‰ç‰ˆæœ¬ä¿¡æ¯
        current_commit = repo.head.commit
        current_info = {
            "hash": current_commit.hexsha[:8],
            "message": current_commit.message.strip(),
            "date": current_commit.committed_datetime.strftime("%Y-%m-%d %H:%M:%S")
        }
        
        # æ£€æŸ¥æ˜¯å¦æœ‰å¯åŠ¨å™¨ç›¸å…³çš„æ›´æ”¹
        launcher_files_in_repo = []
        try:
            for item in repo.tree().traverse():
                if hasattr(item, 'path') and 'ComfyUI-Launcher' in item.path:
                    launcher_files_in_repo.append(item.path)
        except:
            pass
        
        # å®‰å…¨è¯„ä¼°
        safety_level = "safe"
        warnings = []
        
        if launcher_files_in_repo:
            safety_level = "warning"
            warnings.append("è­¦å‘Š å®˜æ–¹ä»“åº“ä¸­å‘ç°äº†å¯åŠ¨å™¨ç›¸å…³æ–‡ä»¶ï¼Œç‰ˆæœ¬åˆ‡æ¢å¯èƒ½æœ‰å†²çªé£é™©")
        
        # æ£€æŸ¥æœ¬åœ°å¯åŠ¨å™¨æ˜¯å¦æœ‰æœªæäº¤çš„æ›´æ”¹
        try:
            changed_files = [item.a_path for item in repo.index.diff(None)]
            unstaged_files = [item.a_path for item in repo.index.diff("HEAD")]
            
            launcher_changes = [f for f in changed_files + unstaged_files if "ComfyUI-Launcher" in f]
            if launcher_changes:
                safety_level = "warning"
                warnings.append("è­¦å‘Š å¯åŠ¨å™¨æœ‰æœ¬åœ°æ›´æ”¹ï¼Œç‰ˆæœ¬åˆ‡æ¢å‰å»ºè®®å¤‡ä»½")
        except:
            pass
        
        recommendations = []
        if safety_level == "warning":
            recommendations.extend([
                " åˆ‡æ¢ç‰ˆæœ¬å‰åˆ›å»ºå¯åŠ¨å™¨å¤‡ä»½",
                " å°†å¯åŠ¨å™¨ç›®å½•åŠ å…¥.gitignore",
                " è®°å½•å½“å‰é…ç½®ä»¥ä¾¿æ¢å¤"
            ])
        else:
            recommendations.append("OK ç‰ˆæœ¬åˆ‡æ¢ç›¸å¯¹å®‰å…¨ï¼Œä½†å»ºè®®å®šæœŸå¤‡ä»½")
        
        return {
            "status": "success",
            "current_version": current_info,
            "safety_level": safety_level,
            "launcher_files_in_repo": launcher_files_in_repo,
            "warnings": warnings,
            "recommendations": recommendations
        }
        
    except Exception as e:
        return {
            "status": "error",
            "message": f"å®‰å…¨æ£€æŸ¥å¤±è´¥: {str(e)}"
        }


@app.post("/nodes/toggle")
async def toggle_node(request: dict):
    """å¯ç”¨/ç¦ç”¨è‡ªå®šä¹‰èŠ‚ç‚¹"""
    try:
        node_name = request.get("node_name")
        enable = request.get("enable", True)
        
        if not node_name:
            return {"status": "error", "message": "æœªæŒ‡å®šèŠ‚ç‚¹åç§°"}
        
        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        custom_nodes_dir = os.path.join(paths["comfyui_path"], "custom_nodes")
        
        # æŸ¥æ‰¾èŠ‚ç‚¹ç›®å½•
        current_name = None
        for item in os.listdir(custom_nodes_dir):
            item_path = os.path.join(custom_nodes_dir, item)
            if not os.path.isdir(item_path):
                continue
            
            # æ£€æŸ¥æ˜¯å¦åŒ¹é…ï¼ˆè€ƒè™‘.disabledåç¼€ï¼‰
            clean_name = item[:-9] if item.endswith('.disabled') else item
            if clean_name == node_name:
                current_name = item
                break
        
        if not current_name:
            return {"status": "error", "message": f"æœªæ‰¾åˆ°èŠ‚ç‚¹: {node_name}"}
        
        current_path = os.path.join(custom_nodes_dir, current_name)
        
        # ç¡®å®šæ–°åç§°
        if enable:
            # å¯ç”¨ï¼šç§»é™¤.disabledåç¼€
            if current_name.endswith('.disabled'):
                new_name = current_name[:-9]
            else:
                return {"status": "success", "message": f"èŠ‚ç‚¹ {node_name} å·²ç»æ˜¯å¯ç”¨çŠ¶æ€"}
        else:
            # ç¦ç”¨ï¼šæ·»åŠ .disabledåç¼€
            if not current_name.endswith('.disabled'):
                new_name = current_name + '.disabled'
            else:
                return {"status": "success", "message": f"èŠ‚ç‚¹ {node_name} å·²ç»æ˜¯ç¦ç”¨çŠ¶æ€"}
        
        new_path = os.path.join(custom_nodes_dir, new_name)
        
        # é‡å‘½åç›®å½•
        os.rename(current_path, new_path)
        
        action = "å¯ç”¨" if enable else "ç¦ç”¨"
        return {
            "status": "success",
            "message": f"èŠ‚ç‚¹ {node_name} {action}æˆåŠŸ",
            "old_name": current_name,
            "new_name": new_name
        }
        
    except Exception as e:
        return {
            "status": "error",
            "message": f"èŠ‚ç‚¹çŠ¶æ€åˆ‡æ¢å¤±è´¥: {str(e)}"
        }

@app.post("/nodes/uninstall")
async def uninstall_node(request: dict):
    """å¸è½½è‡ªå®šä¹‰èŠ‚ç‚¹"""
    try:
        node_name = request.get("node_name")
        create_backup = request.get("create_backup", True)
        
        if not node_name:
            return {"status": "error", "message": "æœªæŒ‡å®šèŠ‚ç‚¹åç§°"}
        
        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        custom_nodes_dir = os.path.join(paths["comfyui_path"], "custom_nodes")
        
        # æŸ¥æ‰¾èŠ‚ç‚¹ç›®å½•
        current_name = None
        for item in os.listdir(custom_nodes_dir):
            item_path = os.path.join(custom_nodes_dir, item)
            if not os.path.isdir(item_path):
                continue
            
            clean_name = item[:-9] if item.endswith('.disabled') else item
            if clean_name == node_name:
                current_name = item
                break
        
        if not current_name:
            return {"status": "error", "message": f"æœªæ‰¾åˆ°èŠ‚ç‚¹: {node_name}"}
        
        current_path = os.path.join(custom_nodes_dir, current_name)
        
        # åˆ›å»ºå¤‡ä»½ï¼ˆå¦‚æœéœ€è¦ï¼‰
        backup_path = None
        if create_backup:
            import datetime
            import shutil
            
            backup_dir = os.path.join(custom_nodes_dir, ".backups")
            os.makedirs(backup_dir, exist_ok=True)
            
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_name = f"{node_name}_backup_{timestamp}"
            backup_path = os.path.join(backup_dir, backup_name)
            
            try:
                shutil.copytree(current_path, backup_path)
            except Exception as backup_error:
                return {
                    "status": "error", 
                    "message": f"åˆ›å»ºå¤‡ä»½å¤±è´¥: {str(backup_error)}"
                }
        
        # åˆ é™¤èŠ‚ç‚¹ç›®å½•ï¼ˆå¤„ç†Windowsæƒé™é—®é¢˜ï¼‰
        import shutil
        import stat

        def handle_remove_readonly(func, path, exc):
            """å¤„ç†åªè¯»æ–‡ä»¶åˆ é™¤"""
            if os.path.exists(path):
                # ç§»é™¤åªè¯»å±æ€§
                os.chmod(path, stat.S_IWRITE)
                func(path)

        try:
            # é¦–å…ˆå°è¯•æ­£å¸¸åˆ é™¤
            shutil.rmtree(current_path)
        except PermissionError:
            try:
                # å¦‚æœæƒé™é”™è¯¯ï¼Œå°è¯•å¼ºåˆ¶åˆ é™¤
                print(f"Permission error, trying force delete for: {current_path}")
                shutil.rmtree(current_path, onerror=handle_remove_readonly)
            except Exception as force_error:
                # å¦‚æœå¼ºåˆ¶åˆ é™¤ä¹Ÿå¤±è´¥ï¼Œå°è¯•ä½¿ç”¨ç³»ç»Ÿå‘½ä»¤
                try:
                    import subprocess
                    print(f"Force delete failed, trying system command for: {current_path}")

                    # ä½¿ç”¨Windowsçš„rmdirå‘½ä»¤å¼ºåˆ¶åˆ é™¤
                    result = subprocess.run(
                        ["rmdir", "/s", "/q", current_path],
                        shell=True,
                        capture_output=True,
                        text=True
                    )

                    if result.returncode != 0:
                        raise Exception(f"ç³»ç»Ÿå‘½ä»¤åˆ é™¤å¤±è´¥: {result.stderr}")

                except Exception as cmd_error:
                    return {
                        "status": "error",
                        "message": f"æ— æ³•åˆ é™¤èŠ‚ç‚¹ç›®å½•: {str(cmd_error)}ã€‚è¯·æ‰‹åŠ¨åˆ é™¤ç›®å½•: {current_path}"
                    }
        
        result = {
            "status": "success",
            "message": f"èŠ‚ç‚¹ {node_name} å¸è½½æˆåŠŸ",
            "deleted_path": current_path
        }
        
        if backup_path:
            result["backup_path"] = backup_path
            result["message"] += f"ï¼Œå¤‡ä»½å·²ä¿å­˜åˆ°: {backup_path}"
        
        return result
        
    except Exception as e:
        return {
            "status": "error",
            "message": f"èŠ‚ç‚¹å¸è½½å¤±è´¥: {str(e)}"
        }

@app.get("/nodes/github-stars/{repo_owner}/{repo_name}")
async def get_github_stars_api(repo_owner: str, repo_name: str):
    """å¼‚æ­¥è·å–GitHubä»“åº“çš„staræ•°"""
    try:
        repo_key = f"{repo_owner}/{repo_name}"
        github_url = f"https://github.com/{repo_key}"

        stars = get_github_stars(github_url)

        return {
            "status": "success",
            "repo": repo_key,
            "stars": stars
        }
    except Exception as e:
        print(f"Error getting GitHub stars for {repo_owner}/{repo_name}: {str(e)}")
        return {
            "status": "error",
            "repo": f"{repo_owner}/{repo_name}",
            "stars": 0,
            "error": str(e)
        }

@app.get("/nodes/available")
async def get_available_nodes():
    """è·å–å¯å®‰è£…çš„èŠ‚ç‚¹åˆ—è¡¨ï¼ˆä»ComfyUI-Manageræ•°æ®æºï¼‰"""
    try:
        # è®¾ç½®ç¼–ç ä¿æŠ¤ç¯å¢ƒ
        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        comfyui_dir = paths["comfyui_path"]
        
        # æŸ¥æ‰¾ComfyUI-Managerçš„èŠ‚ç‚¹åˆ—è¡¨æ–‡ä»¶
        manager_path = os.path.join(comfyui_dir, "custom_nodes", "comfyui-manager")
        node_list_file = os.path.join(manager_path, "custom-node-list.json")

        # å¦‚æœæ²¡æœ‰ComfyUI-Managerï¼Œå°è¯•ä»ç½‘ç»œè·å–æ•°æ®
        if not os.path.exists(node_list_file):
            print("ComfyUI-Manager not found locally, trying to fetch data from network...")
            result = await get_available_nodes_from_network()
            
            # å¯¹è¿”å›ç»“æœè¿›è¡Œå®‰å…¨ç¼–ç å¤„ç†
            if result.get("status") == "success" and "nodes" in result:
                for node in result["nodes"]:
                    for key, value in node.items():
                        if isinstance(value, str):
                            node[key] = safe_encode_string(value)
                        elif isinstance(value, list):
                            node[key] = [safe_encode_string(item) if isinstance(item, str) else item for item in value]
            
            return result
        
        # è¯»å–èŠ‚ç‚¹åˆ—è¡¨
        import json
        with open(node_list_file, 'r', encoding='utf-8') as f:
            data = json.load(f)

        print(f"Loaded ComfyUI-Manager node list from: {node_list_file}")
        print(f"Total available nodes in ComfyUI-Manager: {len(data.get('custom_nodes', []))}")

        # è¯»å–GitHub staræ•°æ®
        github_stats_file = os.path.join(os.path.dirname(node_list_file), "github-stats.json")
        github_stats = {}
        if os.path.exists(github_stats_file):
            try:
                with open(github_stats_file, 'r', encoding='utf-8') as f:
                    github_stats = json.load(f)
                print(f"Loaded GitHub stats from: {github_stats_file}")
                print(f"Total GitHub stats entries: {len(github_stats)}")
            except Exception as e:
                print(f"Error loading GitHub stats: {e}")
                github_stats = {}
        else:
            print(f"GitHub stats file not found: {github_stats_file}")

        # ä½¿ç”¨ç»Ÿä¸€çš„å¤„ç†é€»è¾‘
        result = await process_node_data(data, github_stats)
        
        # å¯¹è¿”å›ç»“æœè¿›è¡Œå®‰å…¨ç¼–ç å¤„ç†
        if result.get("status") == "success" and "nodes" in result:
            for node in result["nodes"]:
                for key, value in node.items():
                    if isinstance(value, str):
                        node[key] = safe_encode_string(value)
                    elif isinstance(value, list):
                        node[key] = [safe_encode_string(item) if isinstance(item, str) else item for item in value]
        
        return result
        
        # å¤„ç†èŠ‚ç‚¹æ•°æ®
        available_nodes = []
        for node in data.get("custom_nodes", []):
            # ç¡®ä¿æœ‰åŸºæœ¬ä¿¡æ¯
            if not node.get("title"):
                continue
                
            # æ£€æŸ¥æ˜¯å¦å·²å®‰è£… - æ”¹è¿›çš„åŒ¹é…é€»è¾‘
            node_title = node.get("title", "").strip()
            node_id = node.get("id", "").strip()

            # ç”Ÿæˆå¤šç§å¯èƒ½çš„åŒ¹é…åç§°
            possible_names = set()

            if node_title:
                possible_names.add(node_title.lower())
                # ç§»é™¤å¸¸è§å‰ç¼€
                title_clean = node_title.lower()
                for prefix in ['comfyui-', 'comfyui_', 'comfy-', 'comfy_']:
                    if title_clean.startswith(prefix):
                        possible_names.add(title_clean[len(prefix):])

                # æ›¿æ¢åˆ†éš”ç¬¦çš„å˜ä½“
                title_variants = [
                    node_title.lower().replace(" ", "-"),
                    node_title.lower().replace(" ", "_"),
                    node_title.lower().replace("-", "_"),
                    node_title.lower().replace("_", "-"),
                    node_title.lower().replace(" ", ""),
                    node_title.lower().replace("-", ""),
                    node_title.lower().replace("_", "")
                ]
                possible_names.update(title_variants)

            if node_id:
                possible_names.add(node_id.lower())

            # æ£€æŸ¥æ˜¯å¦æœ‰åŒ¹é…çš„å·²å®‰è£…æ’ä»¶
            is_installed = False
            for installed_name in installed_nodes:
                installed_lower = installed_name.lower()

                # ç²¾ç¡®åŒ¹é…
                if installed_lower in possible_names:
                    is_installed = True
                    break

                # åŒ…å«åŒ¹é…ï¼ˆåŒå‘ï¼‰
                for possible_name in possible_names:
                    if (possible_name in installed_lower or
                        installed_lower in possible_name) and len(possible_name) > 3:
                        is_installed = True
                        break

                if is_installed:
                    break

            if is_installed:
                print(f"Plugin '{node_title}' detected as installed (matched with: {[name for name in installed_nodes if any(pn in name.lower() or name.lower() in pn for pn in possible_names)]})")
            
            # ç¡®å®šå®‰è£…ç±»å‹
            install_type = node.get("install_type", "git-clone")
            if install_type == "git-clone":
                install_method = "Gitå…‹éš†"
            elif install_type == "copy":
                install_method = "æ–‡ä»¶å¤åˆ¶"
            else:
                install_method = "æœªçŸ¥"
            
            # æå–ä»“åº“URL
            repo_url = ""
            files = node.get("files", [])
            if files:
                repo_url = files[0]
            
            # è‡ªåŠ¨åˆ†ç±»èŠ‚ç‚¹
            category = categorize_node(node.get("title", ""), node.get("description", ""))
            
            # è·å–staræ•°æ®
            stars = 0

            # é¦–å…ˆæ£€æŸ¥ComfyUI-Manageræ•°æ®ä¸­æ˜¯å¦æœ‰starä¿¡æ¯
            if "stars" in node:
                stars = node["stars"]
            elif "star" in node:
                stars = node["star"]
            elif "github_stars" in node:
                stars = node["github_stars"]
            else:
                # ä¼˜å…ˆä½¿ç”¨ComfyUI-Managerçš„GitHub statsæ•°æ®
                reference = node.get("reference", "")
                if reference and reference in github_stats:
                    stars = github_stats[reference].get("stars", 0)
                    if stars > 0:
                        print(f"Using ComfyUI-Manager GitHub stats: {node.get('title', '')} = {stars} stars")

                # å¦‚æœComfyUI-Manageræ²¡æœ‰æ•°æ®ï¼Œæ£€æŸ¥æˆ‘ä»¬çš„ç¼“å­˜
                if stars == 0 and reference and "github.com" in reference:
                    repo_key = extract_repo_key(reference)
                    if repo_key and repo_key in github_stars_cache:
                        # æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿‡æœŸ
                        now = datetime.now()
                        if repo_key in cache_expiry and now < cache_expiry[repo_key]:
                            stars = github_stars_cache[repo_key]

                # æœ€åä½¿ç”¨æ™ºèƒ½ç”Ÿæˆ
                if stars == 0:
                    title = node.get("title", "")
                    stars = generate_smart_stars(title)

            processed_node = {
                "id": safe_encode_string(node_id),  # ä½¿ç”¨å¤„ç†åçš„ID
                "title": safe_encode_string(node.get("title", "")),
                "author": safe_encode_string(node.get("author", "")),
                "description": safe_encode_string(node.get("description", "")),
                "reference": safe_encode_string(node.get("reference", "")),
                "repo_url": safe_encode_string(repo_url),
                "install_type": safe_encode_string(install_type),
                "install_method": safe_encode_string(install_method),
                "is_installed": is_installed,
                "stars": stars,  # æ·»åŠ staræ•°æ®
                "tags": [safe_encode_string(tag) for tag in node.get("tags", [])],
                "nodename_pattern": safe_encode_string(node.get("nodename_pattern", "")),
                "preemptions": [safe_encode_string(p) for p in node.get("preemptions", [])],
                "category": safe_encode_string(category)
            }
            
            available_nodes.append(processed_node)
        
        # ä¸åœ¨åˆå§‹åŠ è½½æ—¶æ‰¹é‡è·å–GitHub staræ•°ï¼Œæé«˜é¡µé¢åŠ è½½é€Ÿåº¦
        print(f"Available plugins loaded with smart star generation")

        # æŒ‰staræ•°æ’åºï¼ˆé™åºï¼‰ï¼Œstaræ•°ç›¸åŒæ—¶æŒ‰æ ‡é¢˜æ’åº
        available_nodes.sort(key=lambda x: (-x["stars"], x["title"].lower()))
        
        return {
            "status": "success",
            "nodes": available_nodes,
            "total_count": len(available_nodes),
            "installed_count": len([n for n in available_nodes if n["is_installed"]]),
            "available_count": len([n for n in available_nodes if not n["is_installed"]])
        }
        
    except Exception as e:
        return {
            "status": "error",
            "message": f"è·å–å¯ç”¨èŠ‚ç‚¹å¤±è´¥: {str(e)}"
        }

@app.post("/nodes/install")
async def install_node(request: dict):
    """å®‰è£…è‡ªå®šä¹‰èŠ‚ç‚¹"""
    try:
        # è®°å½•æ€»å®‰è£…å¼€å§‹æ—¶é—´
        total_start_time = time.time()
        node_id = request.get("node_id")
        repo_url = request.get("repo_url")
        install_type = request.get("install_type", "git-clone")
        
        if not node_id or not repo_url:
            return {"status": "error", "message": "ç¼ºå°‘å¿…è¦å‚æ•°ï¼šnode_id æˆ– repo_url"}
        
        # å¹¶å‘å®‰è£…æ§åˆ¶
        with install_lock:
            if node_id in current_installations:
                return {"status": "error", "message": f"æ’ä»¶ {node_id} æ­£åœ¨å®‰è£…ä¸­ï¼Œè¯·ç¨åå†è¯•"}
            current_installations.add(node_id)
        
        try:
            # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
            paths = get_portable_paths()
            custom_nodes_dir = os.path.join(paths["comfyui_path"], "custom_nodes")
            
            # ç¡®ä¿custom_nodesç›®å½•å­˜åœ¨
            os.makedirs(custom_nodes_dir, exist_ok=True)
            
            # æ ¹æ®å®‰è£…ç±»å‹æ‰§è¡Œä¸åŒçš„å®‰è£…æ–¹æ³•
            if install_type == "git-clone":
                # Gitå…‹éš†å®‰è£…
                import subprocess
                
                # ä»URLæ¨æ–­ç›®å½•åç§°
                if repo_url.endswith('.git'):
                    dir_name = os.path.basename(repo_url)[:-4]
                else:
                    dir_name = os.path.basename(repo_url)
                
                # å¦‚æœç›®å½•åä¸ºç©ºï¼Œä½¿ç”¨node_id
                if not dir_name:
                    dir_name = node_id
                
                target_dir = os.path.join(custom_nodes_dir, dir_name)
                
                # æ£€æŸ¥ç›®å½•æ˜¯å¦å·²å­˜åœ¨
                if os.path.exists(target_dir):
                    return {
                        "status": "error", 
                        "message": f"ç›®å½• {dir_name} å·²å­˜åœ¨ï¼Œå¯èƒ½èŠ‚ç‚¹å·²å®‰è£…"
                    }
                
                try:
                    # GitåŠ é€Ÿä¼˜åŒ– - æ™ºèƒ½é•œåƒæºé€‰æ‹©
                    clone_url = repo_url
                    clone_method = "github"
                    
                    # æµ‹è¯•GitHubè¿æ¥é€Ÿåº¦
                    github_accessible = True
                    test_duration = 999
                    try:
                        print(f" æµ‹è¯•GitHubè¿æ¥: {repo_url}")
                        connection_start = time.time()
                        response = requests.head(repo_url, timeout=3)
                        test_duration = time.time() - connection_start
                        print(f"GitHubè¿æ¥æµ‹è¯•: {test_duration:.2f}ç§’")
                        
                        if response.status_code != 200:
                            github_accessible = False
                    except Exception as e:
                        print(f"ERROR GitHubè¿æ¥å¤±è´¥: {e}")
                        github_accessible = False
                    
                    # å¦‚æœGitHubè®¿é—®æ…¢ï¼Œå°è¯•ä½¿ç”¨é•œåƒæº
                    if not github_accessible or test_duration > 3:
                        print("GitHubè®¿é—®è¾ƒæ…¢ï¼Œå°è¯•ä½¿ç”¨é•œåƒåŠ é€Ÿ...")
                        
                        # ä¸­å›½é•œåƒæºé€‰é¡¹
                        mirror_options = [
                            ("https://ghproxy.com/", "ghproxyé•œåƒ"),
                            ("https://mirror.ghproxy.com/", "ghproxyå¤‡ç”¨é•œåƒ"),
                            ("https://github.moeyy.xyz/", "moeyyé•œåƒ"),
                        ]
                        
                        # å°è¯•é•œåƒæº
                        for mirror_prefix, mirror_name in mirror_options:
                            try:
                                mirror_url = mirror_prefix + repo_url
                                print(f" æµ‹è¯•{mirror_name}: {mirror_url}")
                                
                                mirror_test_start = time.time()
                                mirror_response = requests.head(mirror_url, timeout=3)
                                mirror_test_duration = time.time() - mirror_test_start
                                
                                if mirror_response.status_code == 200 and mirror_test_duration < test_duration:
                                    clone_url = mirror_url
                                    clone_method = mirror_name
                                    print(f"OK ä½¿ç”¨{mirror_name}åŠ é€Ÿï¼Œå“åº”æ—¶é—´: {mirror_test_duration:.2f}ç§’")
                                    break
                            except Exception as e:
                                print(f"ERROR {mirror_name}æµ‹è¯•å¤±è´¥: {e}")
                                continue
                    
                    # è®°å½•å¼€å§‹æ—¶é—´
                    git_start_time = time.time()
                    print(f"å¼€å§‹Gitå…‹éš†: {clone_url} -> {target_dir}")
                    print(f"ä½¿ç”¨æ–¹å¼: {clone_method}")
                    
                    # æ‰§è¡Œgit cloneï¼ˆä¼˜åŒ–ä½†ä¿æŒè¶³å¤Ÿçš„å†å²è®°å½•ï¼‰
                    git_cmd = [
                        "git", "clone", 
                        "--depth=50",             # æµ…å…‹éš†ä½†ä¿ç•™è¶³å¤Ÿå†å²ï¼ˆ50ä¸ªæäº¤ï¼‰
                        "--no-tags",              # ä¸è·å–æ ‡ç­¾
                        "-c", "core.compression=9",  # æœ€å¤§å‹ç¼©
                        "-c", "pack.threads=4",      # å¤šçº¿ç¨‹æ‰“åŒ…
                        clone_url, target_dir
                    ]
                    
                    result = subprocess.run(
                        git_cmd,
                        capture_output=True,
                        text=True,
                        timeout=300,  # 5åˆ†é’Ÿè¶…æ—¶
                    )
                    
                    git_duration = time.time() - git_start_time
                    print(f"Gitå…‹éš†è€—æ—¶: {git_duration:.2f}ç§’")
                    
                    # åˆ†æå…‹éš†é€Ÿåº¦å’Œæ–¹å¼
                    if git_duration > 30:
                        print("è­¦å‘Š  Gitå…‹éš†é€Ÿåº¦è¾ƒæ…¢ï¼Œå¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜")
                    elif git_duration > 10:
                        print("è­¦å‘Š  Gitå…‹éš†é€Ÿåº¦ä¸€èˆ¬")
                    else:
                        print("OK Gitå…‹éš†é€Ÿåº¦æ­£å¸¸")
                    
                    # æ˜¾ç¤ºåŠ é€Ÿæ•ˆæœ
                    if clone_method != "github":
                        print(f"é•œåƒåŠ é€Ÿç”Ÿæ•ˆ: {clone_method}")
                    
                    if result.returncode == 0:
                        # æ£€æŸ¥æ˜¯å¦æœ‰requirements.txtå¹¶å°è¯•å®‰è£…ä¾èµ–
                        requirements_file = os.path.join(target_dir, "requirements.txt")
                        pip_install_log = ""
                        
                        if os.path.exists(requirements_file):
                            try:
                                # è®°å½•pipå®‰è£…å¼€å§‹æ—¶é—´
                                pip_start_time = time.time()
                                print(f"å¼€å§‹å®‰è£…ä¾èµ–: {requirements_file}")
                                
                                # ä¼˜åŒ–pipå®‰è£…ï¼šä½¿ç”¨ç¼“å­˜å’Œå¹¶å‘
                                pip_result = subprocess.run(
                                    [sys.executable, "-m", "pip", "install", "-r", requirements_file, 
                                     "--cache-dir", os.path.expanduser("~/.cache/pip"),
                                     "--disable-pip-version-check"],
                                    capture_output=True,
                                    text=True,
                                    timeout=600  # 10åˆ†é’Ÿè¶…æ—¶
                                )
                                
                                pip_duration = time.time() - pip_start_time
                                print(f"ä¾èµ–å®‰è£…è€—æ—¶: {pip_duration:.2f}ç§’")
                                
                                # åˆ†æpipå®‰è£…é€Ÿåº¦
                                if pip_duration > 60:
                                    print("è­¦å‘Š  ä¾èµ–å®‰è£…é€Ÿåº¦è¾ƒæ…¢ï¼Œå¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜æˆ–å¤§å‹ä¾èµ–åŒ…")
                                elif pip_duration > 20:
                                    print("è­¦å‘Š  ä¾èµ–å®‰è£…é€Ÿåº¦ä¸€èˆ¬")
                                else:
                                    print("OK ä¾èµ–å®‰è£…é€Ÿåº¦æ­£å¸¸")
                                
                                if pip_result.returncode == 0:
                                    pip_install_log = "ä¾èµ–å®‰è£…æˆåŠŸ"
                                else:
                                    pip_install_log = f"ä¾èµ–å®‰è£…è­¦å‘Š: {pip_result.stderr[:200]}"
                            except subprocess.TimeoutExpired:
                                pip_install_log = "ä¾èµ–å®‰è£…è¶…æ—¶ï¼Œè¯·æ‰‹åŠ¨å®‰è£…"
                            except Exception as e:
                                pip_install_log = f"ä¾èµ–å®‰è£…å‡ºé”™: {str(e)[:200]}"
                        
                        # è®°å½•æ€»å®‰è£…æ—¶é—´
                        total_duration = time.time() - total_start_time
                        print(f"æ’ä»¶ {node_id} å®‰è£…å®Œæˆï¼Œæ€»è€—æ—¶: {total_duration:.2f}ç§’")
                        
                        return {
                            "status": "success",
                            "message": f"èŠ‚ç‚¹ {node_id} å®‰è£…æˆåŠŸ",
                            "install_path": target_dir,
                            "pip_log": pip_install_log,
                            "git_output": result.stdout[:500] if result.stdout else "",
                            "install_duration": f"{total_duration:.2f}ç§’"
                        }
                    else:
                        return {
                            "status": "error",
                            "message": f"Gitå…‹éš†å¤±è´¥: {result.stderr[:200]}"
                        }
                        
                except subprocess.TimeoutExpired:
                    return {
                        "status": "error",
                        "message": "å®‰è£…è¶…æ—¶ï¼Œä»“åº“å¯èƒ½å¤ªå¤§æˆ–ç½‘ç»œè¿æ¥é—®é¢˜"
                    }
                except Exception as git_error:
                    return {
                        "status": "error",
                        "message": f"Gitå®‰è£…å‡ºé”™: {str(git_error)}"
                    }
            
            else:
                return {
                    "status": "error",
                    "message": f"ä¸æ”¯æŒçš„å®‰è£…ç±»å‹: {install_type}"
                }
                
        except Exception as git_error:
            return {
                "status": "error",
                "message": f"Gitå®‰è£…å‡ºé”™: {str(git_error)}"
            }
        finally:
            # æ¸…é™¤å¹¶å‘æ§åˆ¶æ ‡è®°
            with install_lock:
                current_installations.discard(node_id)
                
    except Exception as e:
        return {
            "status": "error",
            "message": f"èŠ‚ç‚¹å®‰è£…å¤±è´¥: {str(e)}"
        }
    finally:
        # ç¡®ä¿æ— è®ºå¦‚ä½•éƒ½æ¸…é™¤å¹¶å‘æ§åˆ¶æ ‡è®°
        with install_lock:
            current_installations.discard(node_id)

@app.get("/nodes/check-updates")
async def check_node_updates():
    """æ£€æŸ¥èŠ‚ç‚¹æ›´æ–°"""
    try:
        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        custom_nodes_dir = os.path.join(paths["comfyui_path"], "custom_nodes")
        
        if not os.path.exists(custom_nodes_dir):
            return {"status": "success", "updates": [], "message": "æ— è‡ªå®šä¹‰èŠ‚ç‚¹ç›®å½•"}
        
        updates = []
        checked_count = 0
        error_count = 0
        
        for item in os.listdir(custom_nodes_dir):
            item_path = os.path.join(custom_nodes_dir, item)
            
            # è·³è¿‡æ–‡ä»¶å’ŒéGitä»“åº“
            if not os.path.isdir(item_path) or item.startswith('.'):
                continue
            
            git_dir = os.path.join(item_path, '.git')
            if not os.path.exists(git_dir):
                continue
            
            # è·³è¿‡ç¦ç”¨çš„èŠ‚ç‚¹
            if item.endswith('.disabled'):
                continue
            
            try:
                import subprocess
                
                # è·å–å½“å‰commit
                current_result = subprocess.run(
                    ["git", "rev-parse", "HEAD"],
                    capture_output=True,
                    text=True,
                    cwd=item_path,
                    timeout=30
                )
                
                if current_result.returncode != 0:
                    error_count += 1
                    continue
                
                current_commit = current_result.stdout.strip()
                
                # è·å–è¿œç¨‹ä¿¡æ¯å¹¶æ£€æŸ¥æ›´æ–°
                fetch_result = subprocess.run(
                    ["git", "fetch", "origin"],
                    capture_output=True,
                    text=True,
                    cwd=item_path,
                    timeout=60
                )
                
                if fetch_result.returncode != 0:
                    error_count += 1
                    continue
                
                # è·å–è¿œç¨‹æœ€æ–°commit
                remote_result = subprocess.run(
                    ["git", "rev-parse", "origin/HEAD"],
                    capture_output=True,
                    text=True,
                    cwd=item_path,
                    timeout=30
                )
                
                # å¦‚æœorigin/HEADä¸å­˜åœ¨ï¼Œå°è¯•origin/mainæˆ–origin/master
                if remote_result.returncode != 0:
                    for branch in ["origin/main", "origin/master"]:
                        remote_result = subprocess.run(
                            ["git", "rev-parse", branch],
                            capture_output=True,
                            text=True,
                            cwd=item_path,
                            timeout=30
                        )
                        if remote_result.returncode == 0:
                            break
                
                if remote_result.returncode != 0:
                    error_count += 1
                    continue
                
                remote_commit = remote_result.stdout.strip()
                checked_count += 1
                
                # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ–°
                if current_commit != remote_commit:
                    # è·å–commitä¿¡æ¯
                    log_result = subprocess.run(
                        ["git", "log", "--oneline", f"{current_commit}..{remote_commit}"],
                        capture_output=True,
                        text=True,
                        cwd=item_path,
                        timeout=30
                    )
                    
                    commit_count = len(log_result.stdout.strip().split('\n')) if log_result.stdout.strip() else 0
                    
                    # è·å–æœ€æ–°commitçš„ä¿¡æ¯
                    latest_commit_result = subprocess.run(
                        ["git", "log", "-1", "--format=%s", remote_commit],
                        capture_output=True,
                        text=True,
                        cwd=item_path,
                        timeout=30
                    )
                    
                    latest_message = latest_commit_result.stdout.strip() if latest_commit_result.returncode == 0 else "æ— æ³•è·å–"
                    
                    # è·å–æœ€åæ›´æ–°æ—¶é—´
                    date_result = subprocess.run(
                        ["git", "log", "-1", "--format=%ci", remote_commit],
                        capture_output=True,
                        text=True,
                        cwd=item_path,
                        timeout=30
                    )
                    
                    last_update = date_result.stdout.strip() if date_result.returncode == 0 else ""
                    
                    updates.append({
                        "node_name": item,
                        "current_commit": current_commit[:8],
                        "latest_commit": remote_commit[:8],
                        "commit_count": commit_count,
                        "latest_message": latest_message,
                        "last_update": last_update,
                        "can_update": True
                    })
                
            except subprocess.TimeoutExpired:
                error_count += 1
                continue
            except Exception:
                error_count += 1
                continue
        
        return {
            "status": "success",
            "updates": updates,
            "total_checked": checked_count,
            "error_count": error_count,
            "update_count": len(updates),
            "message": f"æ£€æŸ¥å®Œæˆï¼š{checked_count}ä¸ªèŠ‚ç‚¹å·²æ£€æŸ¥ï¼Œ{len(updates)}ä¸ªæœ‰æ›´æ–°ï¼Œ{error_count}ä¸ªå‡ºé”™"
        }
        
    except Exception as e:
        return {
            "status": "error",
            "message": f"æ£€æŸ¥æ›´æ–°å¤±è´¥: {str(e)}"
        }

# Plugin Management Endpoints  
@app.get("/test/plugins")
async def test_plugins_endpoint():
    """æµ‹è¯•æ’ä»¶ç«¯ç‚¹"""
    return {"status": "success", "message": "Plugin endpoint working"}

@app.get("/api/plugins/installed")
async def get_installed_plugins():
    """è·å–å·²å®‰è£…çš„æ’ä»¶åˆ—è¡¨"""
    try:
        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        custom_nodes_dir = os.path.join(paths["comfyui_path"], "custom_nodes")
        
        if not os.path.exists(custom_nodes_dir):
            return {"status": "success", "plugins": []}
        
        plugins = []
        for item in os.listdir(custom_nodes_dir):
            item_path = os.path.join(custom_nodes_dir, item)
            if os.path.isdir(item_path) and not item.startswith('.'):
                # æ£€æŸ¥æ˜¯å¦æ˜¯Gitä»“åº“
                is_git = os.path.exists(os.path.join(item_path, '.git'))
                
                # æ£€æŸ¥æ˜¯å¦æœ‰Pythonæ–‡ä»¶
                has_py_files = any(f.endswith('.py') for f in os.listdir(item_path) if os.path.isfile(os.path.join(item_path, f)))
                
                if has_py_files:
                    plugin_info = {
                        "name": item,
                        "path": item_path,
                        "enabled": True,  # ç®€åŒ–ï¼šå‡è®¾éƒ½å¯ç”¨
                        "is_git": is_git,
                        "description": f"Custom node: {item}",
                        "version": "unknown"
                    }
                    
                    # å°è¯•è·å–æ›´å¤šä¿¡æ¯
                    try:
                        if is_git:
                            import git
                            repo = git.Repo(item_path)
                            try:
                                latest_commit = repo.head.commit
                                plugin_info["version"] = latest_commit.hexsha[:8]
                                plugin_info["last_update"] = latest_commit.committed_datetime.strftime("%Y-%m-%d")
                            except:
                                pass
                    except:
                        pass
                    
                    plugins.append(plugin_info)
        
        return {"status": "success", "plugins": plugins}
        
    except Exception as e:
        return {"status": "error", "message": f"è·å–æ’ä»¶åˆ—è¡¨å¤±è´¥: {str(e)}"}

@app.post("/api/plugins/toggle")
async def toggle_plugin(request: dict):
    """å¯ç”¨/ç¦ç”¨æ’ä»¶"""
    try:
        plugin_name = request.get("plugin_name")
        enabled = request.get("enabled", True)
        
        if not plugin_name:
            return {"status": "error", "message": "æ’ä»¶åç§°ä¸èƒ½ä¸ºç©º"}
        
        # è¿™é‡Œåº”è¯¥å®ç°å…·ä½“çš„å¯ç”¨/ç¦ç”¨é€»è¾‘
        # ç®€åŒ–ç‰ˆæœ¬ï¼šè¿”å›æˆåŠŸçŠ¶æ€
        return {
            "status": "success", 
            "message": f"æ’ä»¶ {plugin_name} å·²{'å¯ç”¨' if enabled else 'ç¦ç”¨'}"
        }
        
    except Exception as e:
        return {"status": "error", "message": f"æ’ä»¶æ“ä½œå¤±è´¥: {str(e)}"}

@app.post("/plugins/validate-url")
async def validate_plugin_url(request: dict):
    """éªŒè¯æ’ä»¶URLçš„å¯è®¿é—®æ€§"""
    try:
        url = request.get("url")
        if not url:
            return {"status": "error", "message": "URLä¸èƒ½ä¸ºç©º"}

        import requests
        import re

        # æ ‡å‡†åŒ–URL
        if not url.startswith(('http://', 'https://')):
            url = 'https://' + url

        # éªŒè¯URLæ ¼å¼
        github_pattern = r'https://github\.com/[^/]+/[^/]+/?'
        if not re.match(github_pattern, url):
            return {"status": "error", "message": "è¯·æä¾›æœ‰æ•ˆçš„GitHubä»“åº“åœ°å€"}

        # æ£€æŸ¥URLå¯è®¿é—®æ€§
        try:
            response = requests.head(url, timeout=10, allow_redirects=True)
            if response.status_code == 200:
                return {"status": "success", "message": "URLéªŒè¯æˆåŠŸ", "url": url}
            else:
                return {"status": "error", "message": f"æ— æ³•è®¿é—®è¯¥URL (çŠ¶æ€ç : {response.status_code})"}
        except requests.RequestException as e:
            return {"status": "error", "message": f"ç½‘ç»œè¯·æ±‚å¤±è´¥: {str(e)}"}

    except Exception as e:
        return {"status": "error", "message": f"éªŒè¯å¤±è´¥: {str(e)}"}

@app.post("/plugins/install-manual")
async def install_plugin_manual(request: dict):
    """æ‰‹åŠ¨å®‰è£…æ’ä»¶"""
    try:
        url = request.get("url")
        force_install = request.get("force_install", False)

        if not url:
            return {"status": "error", "message": "URLä¸èƒ½ä¸ºç©º"}

        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        custom_nodes_dir = os.path.join(paths["comfyui_path"], "custom_nodes")

        # ç¡®ä¿custom_nodesç›®å½•å­˜åœ¨
        if not os.path.exists(custom_nodes_dir):
            os.makedirs(custom_nodes_dir)

        # ä»URLæå–æ’ä»¶åç§°
        import re
        match = re.search(r'/([^/]+?)(?:\.git)?/?$', url)
        if not match:
            return {"status": "error", "message": "æ— æ³•ä»URLæå–æ’ä»¶åç§°"}

        plugin_name = match.group(1)
        plugin_path = os.path.join(custom_nodes_dir, plugin_name)

        # æ£€æŸ¥æ’ä»¶æ˜¯å¦å·²å­˜åœ¨
        if os.path.exists(plugin_path) and not force_install:
            return {"status": "error", "message": f"æ’ä»¶ {plugin_name} å·²å­˜åœ¨"}

        # å¦‚æœå¼ºåˆ¶å®‰è£…ä¸”ç›®å½•å­˜åœ¨ï¼Œå…ˆåˆ é™¤
        if force_install and os.path.exists(plugin_path):
            import shutil
            shutil.rmtree(plugin_path)

        # å…‹éš†ä»“åº“
        import git
        try:
            git.Repo.clone_from(url, plugin_path)
            return {
                "status": "success",
                "message": f"æ’ä»¶ {plugin_name} å®‰è£…æˆåŠŸ",
                "plugin_name": plugin_name
            }
        except git.GitCommandError as e:
            return {"status": "error", "message": f"Gitå…‹éš†å¤±è´¥: {str(e)}"}
        except Exception as e:
            return {"status": "error", "message": f"å®‰è£…å¤±è´¥: {str(e)}"}

    except Exception as e:
        return {"status": "error", "message": f"å®‰è£…è¿‡ç¨‹å‡ºé”™: {str(e)}"}

@app.post("/api/plugins/update")
async def update_plugin(request: dict):
    """æ›´æ–°æ’ä»¶åˆ°æœ€æ–°ç‰ˆæœ¬"""
    try:
        plugin_name = request.get("plugin_name")

        if not plugin_name:
            return {"status": "error", "message": "æ’ä»¶åç§°ä¸èƒ½ä¸ºç©º"}

        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        comfyui_dir = paths["comfyui_path"]
        plugin_path = os.path.join(comfyui_dir, "custom_nodes", plugin_name)

        if not os.path.exists(plugin_path):
            return {"status": "error", "message": "æ’ä»¶ç›®å½•ä¸å­˜åœ¨"}

        if not os.path.exists(os.path.join(plugin_path, '.git')):
            return {"status": "error", "message": "æ’ä»¶ä¸æ˜¯Gitä»“åº“ï¼Œæ— æ³•æ›´æ–°"}

        import git
        repo = git.Repo(plugin_path)

        # ç¡®å®šä¸»åˆ†æ”¯ï¼ˆæ”¯æŒå¤§å°å†™å˜ä½“ï¼‰
        main_branch = None
        for branch_name in ['main', 'master', 'Main', 'Master']:
            try:
                # æ£€æŸ¥è¿œç¨‹æ˜¯å¦æœ‰è¿™ä¸ªåˆ†æ”¯
                for remote in repo.remotes:
                    if f"{remote.name}/{branch_name}" in [ref.name for ref in remote.refs]:
                        main_branch = branch_name
                        break
                if main_branch:
                    break
            except:
                continue

        if not main_branch:
            return {"status": "error", "message": "æ— æ³•ç¡®å®šä¸»åˆ†æ”¯"}

        try:
            # è·å–å½“å‰çŠ¶æ€
            old_commit = repo.head.commit.hexsha[:8]

            # æ‹‰å–æœ€æ–°ä»£ç 
            origin = repo.remotes.origin
            origin.fetch()

            # åˆ‡æ¢åˆ°ä¸»åˆ†æ”¯å¹¶æ‹‰å–æœ€æ–°ä»£ç 
            repo.git.checkout(main_branch)
            origin.pull(main_branch)

            # è·å–æ–°çŠ¶æ€
            new_commit = repo.head.commit.hexsha[:8]

            # æ¸…é™¤æ’ä»¶ç¼“å­˜
            global plugin_cache, plugin_cache_time, _plugin_version_cache, _plugin_version_cache_time
            plugin_cache = None
            plugin_cache_time = 0

            # æ¸…é™¤è¯¥æ’ä»¶çš„ç‰ˆæœ¬ç¼“å­˜
            if plugin_name in _plugin_version_cache:
                del _plugin_version_cache[plugin_name]
            if plugin_name in _plugin_version_cache_time:
                del _plugin_version_cache_time[plugin_name]

            print(f"Cleared plugin cache and version cache after update for {plugin_name}")

            return {
                "status": "success",
                "message": f"æ’ä»¶ {plugin_name} æ›´æ–°æˆåŠŸ",
                "old_commit": old_commit,
                "new_commit": new_commit,
                "updated": old_commit != new_commit
            }

        except git.exc.GitCommandError as e:
            return {"status": "error", "message": f"Gitæ›´æ–°å¤±è´¥: {str(e)}"}

    except Exception as e:
        return {"status": "error", "message": f"æ’ä»¶æ›´æ–°å¤±è´¥: {str(e)}"}

# æ’ä»¶ç‰ˆæœ¬ç¼“å­˜
_plugin_version_cache = {}
_plugin_version_cache_time = {}
_plugin_version_cache_duration = 1800  # 30åˆ†é’Ÿç¼“å­˜ï¼ˆä¼˜åŒ–åï¼‰

# æ’ä»¶ç‰ˆæœ¬ç®¡ç†API
@app.get("/plugins/{plugin_name}/versions")
async def get_plugin_versions(plugin_name: str, force_refresh: bool = False):
    """è·å–æ’ä»¶çš„Gitç‰ˆæœ¬å†å²"""
    try:
        import git
        import os
        from datetime import datetime
        import time

        # æ£€æŸ¥æ˜¯å¦å¼ºåˆ¶åˆ·æ–°
        if force_refresh:
            print(f"Force refresh requested for plugin versions: {plugin_name}")
            if plugin_name in _plugin_version_cache:
                del _plugin_version_cache[plugin_name]
            if plugin_name in _plugin_version_cache_time:
                del _plugin_version_cache_time[plugin_name]

        # æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆï¼ˆå·²å¯ç”¨ç¼“å­˜ä»¥æå‡æ€§èƒ½ï¼‰
        current_time = time.time()
        if True and (plugin_name in _plugin_version_cache and
            plugin_name in _plugin_version_cache_time and
            (current_time - _plugin_version_cache_time[plugin_name]) < _plugin_version_cache_duration):
            print(f"Using cached version data for {plugin_name} (age: {current_time - _plugin_version_cache_time[plugin_name]:.1f}s)")
            return _plugin_version_cache[plugin_name]

        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        custom_nodes_dir = os.path.join(paths["comfyui_path"], "custom_nodes")
        plugin_dir = os.path.join(custom_nodes_dir, plugin_name)

        if not os.path.exists(plugin_dir):
            return {"status": "error", "message": f"æ’ä»¶ç›®å½•ä¸å­˜åœ¨: {plugin_name}"}

        if not os.path.exists(os.path.join(plugin_dir, ".git")):
            return {"status": "error", "message": f"æ’ä»¶ {plugin_name} ä¸æ˜¯Gitä»“åº“"}

        # æ‰“å¼€Gitä»“åº“
        repo = git.Repo(plugin_dir)

        # è·å–å½“å‰åˆ†æ”¯
        current_branch = repo.active_branch.name if not repo.head.is_detached else "detached"
        current_commit = repo.head.commit.hexsha[:8]

        print(f"DEBUG: Plugin {plugin_name} - Current branch: {current_branch}, Current commit: {current_commit}")

        versions = []

        # åªè·å–ä¸»åˆ†æ”¯çš„æäº¤å†å²ï¼ˆmainæˆ–masterï¼‰
        main_branch = None

        # ç¡®å®šä¸»åˆ†æ”¯åç§°ï¼ˆæ”¯æŒå¤§å°å†™å˜ä½“ï¼‰
        for branch_name in ['main', 'master', 'Main', 'Master']:
            if branch_name in [b.name for b in repo.branches]:
                main_branch = branch_name
                break
            # æ£€æŸ¥è¿œç¨‹åˆ†æ”¯
            for remote in repo.remotes:
                remote_ref_name = f"{remote.name}/{branch_name}"
                if remote_ref_name in [ref.name for ref in remote.refs]:
                    main_branch = branch_name
                    break
            if main_branch:
                break

        if not main_branch:
            main_branch = 'master'  # é»˜è®¤ä½¿ç”¨master

        print(f"Using main branch: {main_branch} for plugin {plugin_name}")

        # é¦–å…ˆå°è¯•è·å–è¿œç¨‹ä¸»åˆ†æ”¯ä¿¡æ¯å’Œæ ‡ç­¾
        try:
            # è·å–è¿œç¨‹ä¿¡æ¯ï¼Œåªè·å–ä¸»åˆ†æ”¯å’Œæ ‡ç­¾
            for remote in repo.remotes:
                try:
                    # é¦–å…ˆå°è¯•è·å–æ›´å¤šå†å²
                    try:
                        # å¯¹äºæµ…å…‹éš†ï¼Œä½¿ç”¨Gitå‘½ä»¤è·å–å®Œæ•´å†å²
                        import subprocess
                        result = subprocess.run(['git', 'fetch', '--unshallow'], 
                                              cwd=plugin_dir, capture_output=True, text=True)
                        if result.returncode == 0:
                            print(f"Fetched complete history using git fetch --unshallow")
                        else:
                            # å¦‚æœunshallowå¤±è´¥ï¼Œå°è¯•æ™®é€šfetch
                            remote.fetch(tags=True, force=True, refspec=f'+refs/heads/{main_branch}:refs/remotes/{remote.name}/{main_branch}')
                            print(f"Fetched main branch '{main_branch}' from remote: {remote.name}")
                    except Exception as fetch_e:
                        # å¦‚æœfetchå¤±è´¥ï¼Œå°è¯•è·å–ä¸»åˆ†æ”¯
                        remote.fetch(tags=True, force=True, refspec=f'+refs/heads/{main_branch}:refs/remotes/{remote.name}/{main_branch}')
                        print(f"Fetched main branch '{main_branch}' from remote: {remote.name}")
                except Exception as e:
                    print(f"Failed to fetch main branch from remote {remote.name}: {e}")
                    # å¦‚æœä¸Šé¢çš„æ–¹å¼å¤±è´¥ï¼Œå°è¯•ç®€å•çš„fetch
                    try:
                        remote.fetch(tags=True)
                        print(f"Fallback fetch successful for remote: {remote.name}")
                    except Exception as e2:
                        print(f"Fallback fetch also failed for remote {remote.name}: {e2}")
        except Exception as e:
            print(f"Error fetching remotes: {e}")

        # è·å–ä¸»åˆ†æ”¯çš„æäº¤å†å²
        try:
            # å°è¯•åˆ‡æ¢åˆ°ä¸»åˆ†æ”¯è·å–æäº¤å†å²
            main_ref = None

            # ä¼˜å…ˆä½¿ç”¨è¿œç¨‹åˆ†æ”¯ï¼ˆè·å–æœ€æ–°ç‰ˆæœ¬ï¼‰
            for remote in repo.remotes:
                remote_ref_name = f"{remote.name}/{main_branch}"
                if remote_ref_name in [ref.name for ref in remote.refs]:
                    main_ref = remote.refs[main_branch]
                    print(f"Using remote branch: {remote_ref_name}")
                    break

            # å¦‚æœæ²¡æœ‰è¿œç¨‹åˆ†æ”¯ï¼Œä½¿ç”¨æœ¬åœ°åˆ†æ”¯
            if not main_ref and main_branch in [b.name for b in repo.branches]:
                main_ref = repo.branches[main_branch]
                print(f"Using local branch: {main_branch}")

            if main_ref:
                # è·å–ä¸»åˆ†æ”¯çš„æ›´å¤šæäº¤ï¼ˆ20ä¸ªï¼‰ï¼Œç¡®ä¿åŒ…å«æœ€æ–°ç‰ˆæœ¬
                commits = list(repo.iter_commits(main_ref, max_count=20))

                for commit in commits:
                    # ç²¾ç¡®æ¯”è¾ƒæäº¤å“ˆå¸Œå€¼ï¼ˆå‰8ä½ï¼‰
                    commit_short = commit.hexsha[:8]
                    is_current = commit_short == current_commit
                    commit_date = datetime.fromtimestamp(commit.committed_date).strftime("%Y-%m-%d")
                    print(f"DEBUG: Commit {commit_short} - Date: {commit_date}, Is current: {is_current}, Current commit: {current_commit}")
                    versions.append({
                        "version": f"{main_branch} ({commit_short})",
                        "type": "commit",
                        "commit": commit_short,
                        "date": commit_date,
                        "message": commit.message.strip().split('\n')[0][:50],
                        "author": commit.author.name,
                        "current": is_current
                    })

        except Exception as e:
            print(f"Error getting main branch commits: {e}")
            # å¦‚æœè·å–ä¸»åˆ†æ”¯å¤±è´¥ï¼Œè‡³å°‘æ·»åŠ å½“å‰æäº¤
            try:
                current_commit_obj = repo.head.commit
                versions.append({
                    "version": f"{current_branch} ({current_commit})",
                    "type": "commit",
                    "commit": current_commit,
                    "date": datetime.fromtimestamp(current_commit_obj.committed_date).strftime("%Y-%m-%d"),
                    "message": current_commit_obj.message.strip().split('\n')[0][:50],
                    "author": current_commit_obj.author.name,
                    "current": True
                })
            except Exception as e2:
                print(f"Error getting current commit: {e2}")

        # æ”¹è¿›çš„æ’åºé€»è¾‘ï¼šä¼˜å…ˆçº§ + æ—¥æœŸ
        def version_sort_key(version):
            # å®šä¹‰ç‰ˆæœ¬ç±»å‹ä¼˜å…ˆçº§
            type_priority = {
                "tag": 1,        # æ ‡ç­¾ç‰ˆæœ¬ä¼˜å…ˆçº§æœ€é«˜
                "branch": 2,     # åˆ†æ”¯æ¬¡ä¹‹
                "remote_branch": 3,  # è¿œç¨‹åˆ†æ”¯
                "commit": 4      # æäº¤ä¼˜å…ˆçº§æœ€ä½
            }

            # å¦‚æœæ˜¯å½“å‰ç‰ˆæœ¬ï¼Œæ ¹æ®æƒ…å†µè°ƒæ•´ä¼˜å…ˆçº§
            if version["current"]:
                # å¦‚æœå½“å‰ç‰ˆæœ¬æ˜¯æ ‡ç­¾ï¼Œä¿æŒé«˜ä¼˜å…ˆçº§
                if version["type"] == "tag":
                    priority = 0  # å½“å‰æ ‡ç­¾ç‰ˆæœ¬ä¼˜å…ˆçº§æœ€é«˜
                else:
                    priority = 1.5  # å½“å‰éæ ‡ç­¾ç‰ˆæœ¬é€‚ä¸­ä¼˜å…ˆçº§
            else:
                priority = type_priority.get(version["type"], 5)

            # è¿”å›æ’åºé”®ï¼š(ä¼˜å…ˆçº§, æ—¥æœŸå€’åº)
            return (priority, version["date"])

        # æŒ‰æ—¶é—´æ’åºï¼ˆä»æœ€æ–°åˆ°æœ€æ—§ï¼‰
        def time_sort_key(version):
            try:
                from datetime import datetime
                date_obj = datetime.strptime(version["date"], "%Y-%m-%d")
                return date_obj
            except:
                return datetime.min

        # æŒ‰æ—¥æœŸæ’åºï¼ˆæœ€æ–°çš„åœ¨å‰ï¼‰
        versions.sort(key=time_sort_key, reverse=True)

        # å»é‡å¹¶é™åˆ¶ä¸º7ä¸ªç‰ˆæœ¬
        seen = set()
        unique_versions = []
        for version in versions:
            key = (version["version"], version["commit"])
            if key not in seen:
                seen.add(key)
                unique_versions.append(version)
                if len(unique_versions) >= 7:
                    break

        # ç¡®ä¿å½“å‰ç‰ˆæœ¬åœ¨åˆ—è¡¨ä¸­ï¼Œä½†ä¸å½±å“æœ€æ–°ç‰ˆæœ¬çš„æ˜¾ç¤º
        current_version_in_list = any(v.get("current", False) for v in unique_versions)
        if not current_version_in_list:
            # å¦‚æœå½“å‰ç‰ˆæœ¬ä¸åœ¨è¿œç¨‹æäº¤åˆ—è¡¨ä¸­ï¼Œæ‰‹åŠ¨åˆ›å»ºå½“å‰ç‰ˆæœ¬æ¡ç›®
            try:
                current_commit_obj = repo.head.commit
                current_version_entry = {
                    "version": f"{current_branch} ({current_commit})",
                    "type": "commit",
                    "commit": current_commit,
                    "date": datetime.fromtimestamp(current_commit_obj.committed_date).strftime("%Y-%m-%d"),
                    "message": current_commit_obj.message.strip().split('\n')[0][:50],
                    "author": current_commit_obj.author.name,
                    "current": True
                }

                if len(unique_versions) < 7:
                    # å¦‚æœåˆ—è¡¨æœªæ»¡ï¼Œç›´æ¥æ·»åŠ å½“å‰ç‰ˆæœ¬
                    unique_versions.append(current_version_entry)
                else:
                    # å¦‚æœåˆ—è¡¨å·²æ»¡ï¼Œåœ¨é€‚å½“ä½ç½®æ’å…¥å½“å‰ç‰ˆæœ¬ï¼Œä¿æŒæ—¶é—´é¡ºåº
                    # ä½†ä¼˜å…ˆä¿ç•™æœ€æ–°çš„ç‰ˆæœ¬
                    current_date = time_sort_key(current_version_entry)
                    inserted = False
                    for i, existing_version in enumerate(unique_versions):
                        if time_sort_key(existing_version) < current_date:
                            unique_versions.insert(i, current_version_entry)
                            unique_versions = unique_versions[:7]  # ä¿æŒ7ä¸ªç‰ˆæœ¬
                            inserted = True
                            break
                    if not inserted:
                        # å¦‚æœå½“å‰ç‰ˆæœ¬æ˜¯æœ€æ—§çš„ï¼Œæ›¿æ¢æœ€åä¸€ä¸ª
                        unique_versions[-1] = current_version_entry

                print(f"Added current version manually: {current_commit} ({current_version_entry['date']})")
            except Exception as e:
                print(f"Error adding current version: {e}")

        # è°ƒè¯•ï¼šæ‰“å°æœ€ç»ˆç‰ˆæœ¬åˆ—è¡¨
        print(f"DEBUG: Final version list for {plugin_name}:")
        for i, version in enumerate(unique_versions):
            current_marker = " [CURRENT]" if version.get("current", False) else ""
            print(f"  {i+1}. {version['commit']} ({version['date']}){current_marker}")

        result = {
            "status": "success",
            "plugin_name": plugin_name,
            "current_branch": current_branch,
            "current_commit": current_commit,
            "versions": unique_versions
        }

        # ç¼“å­˜ç»“æœ
        _plugin_version_cache[plugin_name] = result
        _plugin_version_cache_time[plugin_name] = current_time
        print(f"Cached version data for {plugin_name}")

        return result

    except Exception as e:
        return {"status": "error", "message": f"è·å–æ’ä»¶ç‰ˆæœ¬å¤±è´¥: {str(e)}"}

@app.post("/plugins/{plugin_name}/switch-version")
async def switch_plugin_version(plugin_name: str, request: dict):
    """åˆ‡æ¢æ’ä»¶ç‰ˆæœ¬"""
    try:
        import git
        import os

        version = request.get("version")
        if not version:
            return {"status": "error", "message": "ç‰ˆæœ¬å‚æ•°ä¸èƒ½ä¸ºç©º"}

        # ä½¿ç”¨ä¾¿æºåŒ…è·¯å¾„é…ç½®
        paths = get_portable_paths()
        custom_nodes_dir = os.path.join(paths["comfyui_path"], "custom_nodes")
        plugin_dir = os.path.join(custom_nodes_dir, plugin_name)

        if not os.path.exists(plugin_dir):
            return {"status": "error", "message": f"æ’ä»¶ç›®å½•ä¸å­˜åœ¨: {plugin_name}"}

        if not os.path.exists(os.path.join(plugin_dir, ".git")):
            return {"status": "error", "message": f"æ’ä»¶ {plugin_name} ä¸æ˜¯Gitä»“åº“"}

        # æ‰“å¼€Gitä»“åº“
        repo = git.Repo(plugin_dir)

        # æ£€æŸ¥æ˜¯å¦æœ‰æœªæäº¤çš„æ›´æ”¹
        if repo.is_dirty():
            return {
                "status": "warning",
                "message": f"æ’ä»¶ {plugin_name} æœ‰æœªæäº¤çš„æ›´æ”¹ï¼Œè¯·å…ˆæäº¤æˆ–ä¸¢å¼ƒæ›´æ”¹",
                "dirty_files": [item.a_path for item in repo.index.diff(None)]
            }

        # è·å–å½“å‰çŠ¶æ€
        old_branch = repo.active_branch.name if not repo.head.is_detached else "detached"
        old_commit = repo.head.commit.hexsha[:8]

        # è§£æç‰ˆæœ¬ä¿¡æ¯
        # ç‰ˆæœ¬æ ¼å¼å¯èƒ½æ˜¯: "main (b775441a)" æˆ– "b775441a" æˆ– "v1.0.0"
        commit_hash = None
        branch_name = None

        if '(' in version and ')' in version:
            # æ ¼å¼: "main (b775441a)"
            parts = version.split('(')
            if len(parts) == 2:
                branch_name = parts[0].strip()
                commit_hash = parts[1].replace(')', '').strip()
        else:
            # ç›´æ¥çš„åˆ†æ”¯åã€æ ‡ç­¾åæˆ–æäº¤å“ˆå¸Œ
            if len(version) == 8 and all(c in '0123456789abcdef' for c in version.lower()):
                # çœ‹èµ·æ¥åƒæäº¤å“ˆå¸Œ
                commit_hash = version
            else:
                # å¯èƒ½æ˜¯åˆ†æ”¯åæˆ–æ ‡ç­¾å
                branch_name = version

        print(f"Parsed version '{version}': branch='{branch_name}', commit='{commit_hash}'")

        # æ‰§è¡Œåˆ‡æ¢
        try:
            switch_type = "unknown"

            # ä¼˜å…ˆä½¿ç”¨æäº¤å“ˆå¸Œåˆ‡æ¢ï¼ˆæœ€å‡†ç¡®ï¼‰
            if commit_hash:
                try:
                    repo.git.checkout(commit_hash)
                    switch_type = "commit"
                    print(f"Switched to commit: {commit_hash}")
                except git.exc.GitCommandError as e:
                    print(f"Failed to checkout commit {commit_hash}: {e}")
                    # å¦‚æœæäº¤å“ˆå¸Œå¤±è´¥ï¼Œå°è¯•ä½¿ç”¨åˆ†æ”¯å
                    if branch_name:
                        repo.git.checkout(branch_name)
                        switch_type = "branch"
                        print(f"Switched to branch: {branch_name}")
                    else:
                        raise e

            # å¦‚æœæ²¡æœ‰æäº¤å“ˆå¸Œï¼Œå°è¯•åˆ†æ”¯åæˆ–æ ‡ç­¾
            elif branch_name:
                # å°è¯•åˆ‡æ¢åˆ°æœ¬åœ°åˆ†æ”¯
                if branch_name in [branch.name for branch in repo.branches]:
                    repo.git.checkout(branch_name)
                    switch_type = "local_branch"
                # å°è¯•åˆ‡æ¢åˆ°æ ‡ç­¾
                elif branch_name in [tag.name for tag in repo.tags]:
                    repo.git.checkout(branch_name)
                    switch_type = "tag"
                    # æ‰¾åˆ°å¯¹åº”çš„è¿œç¨‹åˆ†æ”¯
                    remote_ref = None
                    for remote in repo.remotes:
                        for ref in remote.refs:
                            if ref.name.endswith(f'/{branch_name}'):
                                remote_ref = ref
                                break
                        if remote_ref:
                            break

                    if remote_ref:
                        # åˆ›å»ºæœ¬åœ°è·Ÿè¸ªåˆ†æ”¯
                        repo.git.checkout('-b', branch_name, remote_ref.name)
                        switch_type = "remote_branch"
                    else:
                        raise Exception(f"Branch or tag '{branch_name}' not found")
                else:
                    raise Exception(f"Branch or tag '{branch_name}' not found")
            else:
                raise Exception("No valid version information provided")

            # è·å–æ–°çŠ¶æ€
            new_branch = repo.active_branch.name if not repo.head.is_detached else "detached"
            new_commit = repo.head.commit.hexsha[:8]

            # æ¸…é™¤æ’ä»¶ç¼“å­˜ï¼Œç¡®ä¿ä¸‹æ¬¡è¯·æ±‚è·å–æœ€æ–°æ•°æ®
            global plugin_cache, plugin_cache_time, _plugin_version_cache, _plugin_version_cache_time
            plugin_cache = None
            plugin_cache_time = 0

            # æ¸…é™¤è¯¥æ’ä»¶çš„ç‰ˆæœ¬ç¼“å­˜
            if plugin_name in _plugin_version_cache:
                del _plugin_version_cache[plugin_name]
            if plugin_name in _plugin_version_cache_time:
                del _plugin_version_cache_time[plugin_name]

            print(f"Cleared plugin cache and version cache after version switch for {plugin_name}")

            return {
                "status": "success",
                "message": f"æˆåŠŸåˆ‡æ¢ {plugin_name} åˆ° {version}",
                "plugin_name": plugin_name,
                "switch_type": switch_type,
                "old_version": {"branch": old_branch, "commit": old_commit},
                "new_version": {"branch": new_branch, "commit": new_commit}
            }

        except git.exc.GitCommandError as e:
            return {"status": "error", "message": f"Gitåˆ‡æ¢å¤±è´¥: {str(e)}"}

    except Exception as e:
        return {"status": "error", "message": f"åˆ‡æ¢æ’ä»¶ç‰ˆæœ¬å¤±è´¥: {str(e)}"}

# è·å–ç»ˆç«¯ç¯å¢ƒä¿¡æ¯API
@app.get("/terminal/info")
async def get_terminal_info():
    """è·å–ç»ˆç«¯ç¯å¢ƒä¿¡æ¯"""
    try:
        # è·å–ä¾¿æºåŒ…ç¯å¢ƒè·¯å¾„
        portable_paths = get_portable_paths()

        # å·¥ä½œç›®å½•
        work_dir = Path(portable_paths['portable_root'])

        # è™šæ‹Ÿç¯å¢ƒè·¯å¾„
        venv_path = Path(portable_paths['venv_path'])

        # æ£€æŸ¥è™šæ‹Ÿç¯å¢ƒç±»å‹
        env_type = "æœªçŸ¥"
        env_status = "æœªæ¿€æ´»"

        if venv_path.exists():
            # æ£€æŸ¥æ˜¯å¦æ˜¯condaç¯å¢ƒ
            conda_meta_path = venv_path / "conda-meta"
            if conda_meta_path.exists():
                env_type = "conda"
                env_status = "å·²æ¿€æ´»"
            else:
                # æ£€æŸ¥æ˜¯å¦æ˜¯æ™®é€šè™šæ‹Ÿç¯å¢ƒ
                if os.name == 'nt':
                    activate_script = venv_path / "Scripts" / "activate.bat"
                else:
                    activate_script = venv_path / "bin" / "activate"

                if activate_script.exists():
                    env_type = "venv"
                    env_status = "å·²æ¿€æ´»"

        # è·å–Pythonç‰ˆæœ¬ä¿¡æ¯
        python_version = "æœªçŸ¥"
        try:
            if venv_path.exists():
                if env_type == "conda":
                    python_exe = venv_path / "python.exe" if os.name == 'nt' else venv_path / "bin" / "python"
                else:
                    python_exe = venv_path / "Scripts" / "python.exe" if os.name == 'nt' else venv_path / "bin" / "python"

                if python_exe.exists():
                    result = subprocess.run([str(python_exe), "--version"],
                                          capture_output=True, text=True, timeout=5)
                    if result.returncode == 0:
                        python_version = result.stdout.strip()
        except Exception as e:
            print(f"Failed to get Python version: {e}")

        return {
            "work_dir": str(work_dir),
            "venv_path": str(venv_path),
            "venv_exists": venv_path.exists(),
            "env_type": env_type,
            "env_status": env_status,
            "python_version": python_version,
            "comfyui_path": str(Path(portable_paths['comfyui_path'])),
            "prompt": f"{env_type}> " if env_type != "æœªçŸ¥" else "cmd> "
        }
    except Exception as e:
        return {
            "error": str(e),
            "work_dir": "æ£€æµ‹å¤±è´¥",
            "venv_path": "æ£€æµ‹å¤±è´¥",
            "venv_exists": False,
            "env_type": "æœªçŸ¥",
            "env_status": "æ£€æµ‹å¤±è´¥",
            "python_version": "æ£€æµ‹å¤±è´¥",
            "comfyui_path": "æ£€æµ‹å¤±è´¥",
            "prompt": "cmd> "
        }

# ç»ˆç«¯æ‰§è¡ŒAPI
@app.post("/terminal/execute")
async def execute_terminal_command(command_data: dict):
    """æ‰§è¡Œç»ˆç«¯å‘½ä»¤"""
    try:
        command = command_data.get("command", "").strip()
        if not command:
            return {"error": "å‘½ä»¤ä¸èƒ½ä¸ºç©º"}

        # å®‰å…¨æ£€æŸ¥ - åªå…è®¸ç‰¹å®šçš„å®‰å…¨å‘½ä»¤
        safe_commands = [
            "pip", "python", "git", "ls", "dir", "pwd", "cd",
            "echo", "cat", "type", "help", "which", "where",
            "conda", "npm", "node", "nvcc", "nvidia-smi"
        ]

        command_parts = command.split()
        if not command_parts:
            return {"error": "æ— æ•ˆå‘½ä»¤"}

        base_command = command_parts[0].lower()

        # ç‰¹æ®Šå¤„ç†ä¸€äº›å‘½ä»¤
        if base_command == "help":
            return {
                "output": """å¯ç”¨å‘½ä»¤:
â€¢ pip list - æŸ¥çœ‹å·²å®‰è£…çš„PythonåŒ…
â€¢ pip show package_name - æŸ¥çœ‹åŒ…è¯¦æƒ…
â€¢ python --version - æŸ¥çœ‹Pythonç‰ˆæœ¬
â€¢ python -c "import torch; print(torch.__version__)" - æŸ¥çœ‹PyTorchç‰ˆæœ¬
â€¢ git status - æŸ¥çœ‹GitçŠ¶æ€
â€¢ git log --oneline -10 - æŸ¥çœ‹æœ€è¿‘10æ¬¡æäº¤
â€¢ nvidia-smi - æŸ¥çœ‹GPUä¿¡æ¯
â€¢ nvcc --version - æŸ¥çœ‹CUDAç‰ˆæœ¬
â€¢ ls / dir - åˆ—å‡ºæ–‡ä»¶
â€¢ pwd - æ˜¾ç¤ºå½“å‰ç›®å½•""",
                "error": None
            }

        if base_command == "clear":
            return {"output": "", "clear": True, "error": None}

        # æ£€æŸ¥å‘½ä»¤æ˜¯å¦åœ¨å®‰å…¨åˆ—è¡¨ä¸­
        if base_command not in safe_commands:
            return {
                "error": f"å‘½ä»¤ '{base_command}' ä¸è¢«å…è®¸æ‰§è¡Œã€‚è¾“å…¥ 'help' æŸ¥çœ‹å¯ç”¨å‘½ä»¤ã€‚",
                "output": ""
            }

        # è·å–ä¾¿æºåŒ…ç¯å¢ƒè·¯å¾„
        portable_paths = get_portable_paths()

        # è®¾ç½®å·¥ä½œç›®å½•ä¸ºä¾¿æºåŒ…æ ¹ç›®å½•
        work_dir = Path(portable_paths['portable_root'])

        # è®¾ç½®è™šæ‹Ÿç¯å¢ƒè·¯å¾„
        venv_path = Path(portable_paths['venv_path'])
        env = os.environ.copy()

        print(f"Terminal command received: '{command}'")
        print(f"Working directory: {work_dir}")
        print(f"Virtual environment path: {venv_path}")
        print(f"Virtual environment exists: {venv_path.exists()}")

        # æ£€æŸ¥æ˜¯å¦æ˜¯condaç¯å¢ƒ
        is_conda_env = False
        conda_env_path = str(venv_path)

        # å¦‚æœè™šæ‹Ÿç¯å¢ƒå­˜åœ¨ï¼Œæ£€æŸ¥æ˜¯å¦æ˜¯condaç¯å¢ƒ
        if venv_path.exists():
            # æ£€æŸ¥æ˜¯å¦æœ‰conda-metaç›®å½•ï¼ˆcondaç¯å¢ƒçš„æ ‡å¿—ï¼‰
            conda_meta_path = venv_path / "conda-meta"
            print(f"Conda meta path: {conda_meta_path}")
            print(f"Conda meta exists: {conda_meta_path.exists()}")
            if conda_meta_path.exists():
                is_conda_env = True
                print(f"Detected conda environment at: {venv_path}")
            else:
                print(f"Not a conda environment (no conda-meta directory)")

            if is_conda_env:
                # Condaç¯å¢ƒå¤„ç† - condaç¯å¢ƒçš„ç»“æ„ä¸æ™®é€švenvä¸åŒ
                if os.name == 'nt':  # Windows
                    # åœ¨condaç¯å¢ƒä¸­ï¼Œpython.exeåœ¨æ ¹ç›®å½•
                    venv_python = venv_path / "python.exe"
                    venv_pip = venv_path / "Scripts" / "pip.exe"
                    print(f"Using conda Python: {venv_python}")
                    print(f"Using conda pip: {venv_pip}")
                else:  # Linux/Mac
                    venv_python = venv_path / "bin" / "python"
                    venv_pip = venv_path / "bin" / "pip"

                # è®¾ç½®condaç¯å¢ƒå˜é‡
                env['CONDA_DEFAULT_ENV'] = str(venv_path)
                env['CONDA_PREFIX'] = str(venv_path)
                env['CONDA_PYTHON_EXE'] = str(venv_python)

                # æ›´æ–°PATHï¼Œå°†condaç¯å¢ƒçš„bin/Scriptsç›®å½•æ”¾åœ¨æœ€å‰é¢
                if os.name == 'nt':
                    scripts_path = str(venv_path / "Scripts")
                    library_bin = str(venv_path / "Library" / "bin")
                    env['PATH'] = f"{venv_path};{scripts_path};{library_bin};" + env.get('PATH', '')
                else:
                    bin_path = str(venv_path / "bin")
                    env['PATH'] = f"{bin_path}:" + env.get('PATH', '')

                # ç›´æ¥æ›¿æ¢pythonå’Œpipå‘½ä»¤ä¸ºcondaç¯å¢ƒä¸­çš„å¯æ‰§è¡Œæ–‡ä»¶
                original_command = command
                if command.startswith('python ') or command == 'python':
                    command = command.replace('python', f'"{venv_python}"', 1)
                    print(f"Command replaced: '{original_command}' -> '{command}'")
                elif command.startswith('pip ') or command == 'pip':
                    command = command.replace('pip', f'"{venv_pip}"', 1)
                    print(f"Command replaced: '{original_command}' -> '{command}'")
                elif command.startswith('conda '):
                    # å¯¹äºcondaå‘½ä»¤ï¼Œä¿æŒåŸæ ·ï¼Œä½†ç¡®ä¿åœ¨æ­£ç¡®çš„ç¯å¢ƒä¸­æ‰§è¡Œ
                    print(f"Conda command: '{command}'")
                else:
                    print(f"Other command: '{command}'")

            else:
                # æ™®é€šè™šæ‹Ÿç¯å¢ƒå¤„ç†ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
                if os.name == 'nt':  # Windows
                    venv_python = venv_path / "Scripts" / "python.exe"
                    venv_pip = venv_path / "Scripts" / "pip.exe"
                    scripts_path = str(venv_path / "Scripts")
                    activate_script = venv_path / "Scripts" / "activate.bat"
                else:  # Linux/Mac
                    venv_python = venv_path / "bin" / "python"
                    venv_pip = venv_path / "bin" / "pip"
                    scripts_path = str(venv_path / "bin")
                    activate_script = venv_path / "bin" / "activate"

                # è®¾ç½®è™šæ‹Ÿç¯å¢ƒå˜é‡
                env['VIRTUAL_ENV'] = str(venv_path)
                env['PATH'] = scripts_path + os.pathsep + env.get('PATH', '')

                # ç§»é™¤PYTHONHOMEä»¥é¿å…å†²çª
                if 'PYTHONHOME' in env:
                    del env['PYTHONHOME']

                # å¯¹äºWindowsï¼Œä½¿ç”¨cmd /cæ¥æ¿€æ´»è™šæ‹Ÿç¯å¢ƒå¹¶æ‰§è¡Œå‘½ä»¤
                if os.name == 'nt':
                    # å¯¹äºPythonå’Œpipå‘½ä»¤ï¼Œç›´æ¥ä½¿ç”¨è™šæ‹Ÿç¯å¢ƒçš„å¯æ‰§è¡Œæ–‡ä»¶
                    if command.startswith('python ') or command == 'python':
                        command = command.replace('python', f'"{venv_python}"', 1)
                    elif command.startswith('pip ') or command == 'pip':
                        command = command.replace('pip', f'"{venv_pip}"', 1)
                    else:
                        # å¯¹äºå…¶ä»–å‘½ä»¤ï¼Œé€šè¿‡æ¿€æ´»è„šæœ¬æ¥æ‰§è¡Œ
                        command = f'"{activate_script}" && {command}'
                else:
                    # Linux/Mac
                    if command.startswith('python ') or command == 'python':
                        command = command.replace('python', str(venv_python), 1)
                    elif command.startswith('pip ') or command == 'pip':
                        command = command.replace('pip', str(venv_pip), 1)
                    else:
                        command = f'source "{activate_script}" && {command}'

        # æ‰§è¡Œå‘½ä»¤
        try:
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                timeout=30,  # 30ç§’è¶…æ—¶
                cwd=work_dir,
                env=env,  # ä½¿ç”¨ä¿®æ”¹åçš„ç¯å¢ƒå˜é‡
                encoding='utf-8',
                errors='replace'
            )

            output = ""
            if result.stdout:
                output += result.stdout
            if result.stderr:
                if output:
                    output += "\n"
                output += result.stderr

            return {
                "output": output or "å‘½ä»¤æ‰§è¡Œå®Œæˆï¼Œæ— è¾“å‡º",
                "return_code": result.returncode,
                "error": None if result.returncode == 0 else f"å‘½ä»¤æ‰§è¡Œå¤±è´¥ (é€€å‡ºç : {result.returncode})"
            }

        except subprocess.TimeoutExpired:
            return {"error": "å‘½ä»¤æ‰§è¡Œè¶…æ—¶ (30ç§’)", "output": ""}
        except Exception as e:
            return {"error": f"å‘½ä»¤æ‰§è¡Œå¤±è´¥: {str(e)}", "output": ""}

    except Exception as e:
        return {"error": f"å¤„ç†å‘½ä»¤æ—¶å‡ºé”™: {str(e)}", "output": ""}

if __name__ == "__main__":
    # é»˜è®¤é…ç½®
    host = "127.0.0.1"
    port = 8404
    
    # å…è®¸é€šè¿‡å‘½ä»¤è¡Œå‚æ•°è¦†ç›–
    if len(sys.argv) > 1:
        host = sys.argv[1]
    if len(sys.argv) > 2:
        try:
            port = int(sys.argv[2])
        except ValueError:
            print(f"Error: Invalid port number '{sys.argv[2]}'")
            sys.exit(1)
            
    # æ£€æµ‹ç½‘ç»œç¯å¢ƒï¼Œä¼˜åŒ–å›½å†…ç”¨æˆ·ä½“éªŒ
    def check_github_connectivity():
        """å¿«é€Ÿæ£€æµ‹GitHubè¿é€šæ€§"""
        try:
            response = requests.get("https://api.github.com", timeout=1)
            return response.status_code == 200
        except:
            return False

    github_accessible = check_github_connectivity()
    if github_accessible:
        print("GitHub API è¿æ¥æ­£å¸¸")
    else:
        print("GitHub API è¿æ¥è¾ƒæ…¢ï¼Œå°†ä¼˜å…ˆä½¿ç”¨å›½å†…é•œåƒæº")

    print(f"Starting ComfyUI Launcher Backend (CORS Fixed) on http://{host}:{port}")

    # å¯åŠ¨UvicornæœåŠ¡å™¨
    uvicorn.run(
        "start_fixed_cors:app", 
        host=host, 
        port=port, 
        reload=False,
        log_level="info"
    )